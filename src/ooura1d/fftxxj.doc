汎用FFT (高速 フーリエ/コサイン/サイン 変換) パッケージ


【概要】

    一次元，２の整数乗個のデータの離散Fourier変換，コサイン変換，サイン
    変換等を行います．


【ファイル内容】

    fft2f.c  : CによるFFTパッケージ 簡易版
    fft2f.f  : FortranによるFFTパッケージ 簡易版
    fft2ft.c : "fft2f.c" のテスト
    fft2ft.f : "fft2f.f" のテスト
    fft4f.c  : CによるFFTパッケージ 標準版
    fft4f.f  : FortranによるFFTパッケージ 標準版
    fft4g.c  : CによるFFTパッケージ 高速版
    fft4g.f  : FortranによるFFTパッケージ 高速版
    fft4xt.c : "fft4*.c" のテスト
    fft4xt.f : "fft4*.f" のテスト


【ファイルの違い】

    C版とFortran版の内容はまったく同じ．
    簡易版は作業用配列を一切使わない．
    標準版と高速版は三角関数表などの作業用配列を使う．
    標準版と高速版は簡易版に比べて高速かつ高精度．
    標準版と高速版の仕様は同じ．


【ルーチン内容】

    cdft : 複素離散Fourier変換
    rdft : 実離散Fourier変換/逆変換
    ddct : 離散コサイン変換/逆変換
    ddst : 離散サイン変換/逆変換
    dfct : rdftのコサイン変換(実対称な場合の離散Fourier変換)
    dfst : rdftのサイン変換(実反対称な場合の離散Fourier変換)


【使い方】

    はじめに:
        簡潔な使用法は，パッケージプログラムのコメントにもあります．使用
        の具体例は，テストプログラムを参照して下さい．三角関数表，作業領
        域は，fft4*.* のみで使用するので fft2f.* を使う場合は無視してく
        ださい．

    ◆複素離散Fourier変換 :
        <場合１>
            X[k] = Σ_j=0^n-1 x[j]*exp(2*π*i*j*k/n), 0<=k<n
        <場合２>
            X[k] = Σ_j=0^n-1 x[j]*exp(-2*π*i*j*k/n), 0<=k<n
        を求める．
            (注意: Σ_j=0^n-1 は j=0 から n-1 までの和とする)

        [書式]
            fft2f.cの場合
                <場合１>
                    cdft(2*n, cos(M_PI/n), sin(M_PI/n), a);
                <場合２>
                    cdft(2*n, cos(M_PI/n), -sin(M_PI/n), a);
            fft2f.fの場合
                <場合１>
                    call cdft(2*n, cos(pi/n), sin(pi/n), a)
                <場合２>
                    call cdft(2*n, cos(pi/n), -sin(pi/n), a)
            fft4*.cの場合
                <場合１>
                    ip[0] = 0; // 二回目以降の呼び出しには不要
                    cdft(2*n, 1, a, ip, w);
                <場合２>
                    ip[0] = 0; // 二回目以降の呼び出しには不要
                    cdft(2*n, -1, a, ip, w);
            fft4*.fの場合
                <場合１>
                    ip(0) = 0  ! 二回目以降の呼び出しには不要
                    call cdft(2*n, 1, a, ip, w)
                <場合２>
                    ip(0) = 0  ! 二回目以降の呼び出しには不要
                    call cdft(2*n, -1, a, ip, w)

        [引数]
            2*n : データ長(実数データに換算した長さ)
                      型     : 整数
                      詳細   : n は 1 以上で２のベキ乗に選ぶ．
            a   : 入出力データ
                      型     : 倍精度実数型配列
                      サイズ : 0 から 2*n-1 まで
                      詳細   : a[2*j], a[2*j+1] はそれぞれ x[j] または
                               X[j] の実部, 虚部に対応する．結果は上書き
                               される．Fortranでは引数の型をチェックしな
                               いため，倍精度複素数型配列をそのまま引数
                               にできる．

            ip  : ビット反転用作業領域
                      型     : 整数型配列
                      サイズ : 0 から 1+sqrt(n) まで(正確には 1+sqrt(n)
                               と 1+sqrt(n/2) の割り切れる方まで)
                      詳細   : ip[2...*] が作業領域で，ip[0], ip[1] は表
                               の管理データ(値の変更は不可)である．
            w   : 三角関数表
                      型     : 倍精度実数型配列
                      サイズ : 0 から n/2-1 まで
                      詳細   : 三角関数表は ip[0] が 0 のときに初期化さ
                               れる．

        [注意]
            離散Fourier変換/逆変換の定義として
                場合１を逆変換，場合２の1/n倍を順変換と呼ぶ場合，
                場合１を順変換，場合２の1/n倍を逆変換と呼ぶ場合，
                場合１の1/n倍を逆変換，場合２を順変換と呼ぶ場合，
                場合１の1/n倍を順変換，場合２を逆変換と呼ぶ場合，
                その他，
            がある．

    ◆実離散Fourier変換/逆変換 :
        <場合１> (RDFT)
            R[k] = Σ_j=0^n-1 a[j]*cos(2*π*j*k/n), 0<=k<=n/2
            I[k] = Σ_j=0^n-1 a[j]*sin(2*π*j*k/n), 0<k<n/2
        <場合２> (IRDFT)
            A[k] = (R[0] + R[n/2]*cos(pi*k))/2 + 
                   Σ_j=1^n/2-1 R[j]*cos(2*π*j*k/n) + 
                   Σ_j=1^n/2-1 I[j]*sin(2*π*j*k/n), 0<=k<n
        を求める．

        [書式]
            fft2f.cの場合
                <場合１>
                    rdft(n, cos(M_PI/n), sin(M_PI/n), a);
                <場合２>
                    rdft(n, cos(M_PI/n), -sin(M_PI/n), a);
            fft2f.fの場合
                <場合１>
                    call rdft(n, cos(pi/n), sin(pi/n), a)
                <場合２>
                    call rdft(n, cos(pi/n), -sin(pi/n), a)
            fft4*.cの場合
                <場合１>
                    ip[0] = 0; // 二回目以降の呼び出しには不要
                    rdft(n, 1, a, ip, w);
                <場合２>
                    ip[0] = 0; // 二回目以降の呼び出しには不要
                    rdft(n, -1, a, ip, w);
            fft4*.fの場合
                <場合１>
                    ip(0) = 0  ! 二回目以降の呼び出しには不要
                    call rdft(n, 1, a, ip, w)
                <場合２>
                    ip(0) = 0  ! 二回目以降の呼び出しには不要
                    call rdft(n, -1, a, ip, w)

        [引数]
            n   : データ長
                      型     : 整数
                      詳細   : n は 2 以上で２のベキ乗に選ぶ．
            a   : 入出力データ
                      型     : 倍精度実数型配列
                      サイズ : 0 から n-1 まで
                      詳細   : 場合１の出力
                                   a[2*k] = R[k], 0<=k<n/2
                                   a[2*k+1] = I[k], 0<k<n/2
                                   a[1] = R[n/2]
                               場合２の入力
                                   a[2*j] = R[j], 0<=j<n/2
                                   a[2*j+1] = I[j], 0<j<n/2
                                   a[1] = R[n/2]

            ip  : ビット反転用作業領域
                      型     : 整数型配列
                      サイズ : 0 から 1+sqrt(n/2) まで(正確には 1+sqrt(n/2)
                               と 1+sqrt(n/4) の割り切れる方まで)
                      詳細   : ip[2...*] が作業領域で，ip[0], ip[1] は表
                               の管理データ(値の変更は不可)である．
            w   : 三角関数表
                      型     : 倍精度実数型配列
                      サイズ : 0 から n/2-1 まで
                      詳細   : 三角関数表は ip[0] が 0 のときに初期化さ
                               れる．

        [注意]
            正確には，場合１の逆変換は，場合２の変換の 2/n 倍である．

    ◆離散コサイン変換/逆変換 :
        <場合１> (IDCT)
            C[k] = Σ_j=0^n-1 a[j]*cos(π*j*(k+1/2)/n), 0<=k<n
        <場合２> (DCT)
            C[k] = Σ_j=0^n-1 a[j]*cos(π*(j+1/2)*k/n), 0<=k<n
        を求める．

        [書式]
            fft2f.cの場合
                <場合１>
                    ddct(n, cos(M_PI/n/2), sin(M_PI/n/2), a);
                <場合２>
                    ddct(n, cos(M_PI/n/2), -sin(M_PI/n/2), a);
            fft2f.fの場合
                <場合１>
                    call ddct(n, cos(pi/n/2), sin(pi/n/2), a)
                <場合２>
                    call ddct(n, cos(pi/n/2), -sin(pi/n/2), a)
            fft4*.cの場合
                <場合１>
                    ip[0] = 0; // 二回目以降の呼び出しには不要
                    ddct(n, 1, a, ip, w);
                <場合２>
                    ip[0] = 0; // 二回目以降の呼び出しには不要
                    ddct(n, -1, a, ip, w);
            fft4*.fの場合
                <場合１>
                    ip(0) = 0  ! 二回目以降の呼び出しには不要
                    call ddct(n, 1, a, ip, w)
                <場合２>
                    ip(0) = 0  ! 二回目以降の呼び出しには不要
                    call ddct(n, -1, a, ip, w)

        [引数]
            n   : データ長
                      型     : 整数
                      詳細   : n は 2 以上で２のベキ乗に選ぶ．
            a   : 入出力データ
                      型     : 倍精度実数型配列
                      サイズ : 0 から n-1 まで
                      詳細   : 結果: C[k] は a[k] に上書きされる．

            ip  : ビット反転用作業領域
                      型     : 整数型配列
                      サイズ : 0 から 1+sqrt(n/2) まで(正確には 1+sqrt(n/2)
                               と 1+sqrt(n/4) の割り切れる方まで)
                      詳細   : ip[2...*] が作業領域で，ip[0], ip[1] は表
                               の管理データ(値の変更は不可)である．
            w   : 三角関数表
                      型     : 倍精度実数型配列
                      サイズ : 0 から n*5/4-1 まで
                      詳細   : 三角関数表は ip[0] が 0 のときに初期化さ
                               れる．

        [注意]
            正確には，場合２の逆変換は，a[0] を 1/n 倍，他の a[j] を 2/n
            倍した，場合１の変換である．

    ◆離散サイン変換/逆変換 :
        <場合１> (IDST)
            S[k] = Σ_j=1^n A[j]*sin(π*j*(k+1/2)/n), 0<=k<n
        <場合２> (DST)
            S[k] = Σ_j=0^n-1 a[j]*sin(π*(j+1/2)*k/n), 0<k<=n
        を求める．

        [書式]
            fft2f.cの場合
                <場合１>
                    ddst(n, cos(M_PI/n/2), sin(M_PI/n/2), a);
                <場合２>
                    ddst(n, cos(M_PI/n/2), -sin(M_PI/n/2), a);
            fft2f.fの場合
                <場合１>
                    call ddst(n, cos(pi/n/2), sin(pi/n/2), a)
                <場合２>
                    call ddst(n, cos(pi/n/2), -sin(pi/n/2), a)
            fft4*.cの場合
                <場合１>
                    ip[0] = 0; // 二回目以降の呼び出しには不要
                    ddst(n, 1, a, ip, w);
                <場合２>
                    ip[0] = 0; // 二回目以降の呼び出しには不要
                    ddst(n, -1, a, ip, w);
            fft4*.fの場合
                <場合１>
                    ip(0) = 0  ! 二回目以降の呼び出しには不要
                    call ddst(n, 1, a, ip, w)
                <場合２>
                    ip(0) = 0  ! 二回目以降の呼び出しには不要
                    call ddst(n, -1, a, ip, w)

        [引数]
            n   : データ長
                      型     : 整数
                      詳細   : n は 2 以上で２のベキ乗に選ぶ．
            a   : 入出力データ
                      型     : 倍精度実数型配列
                      サイズ : 0 から n-1 まで
                      詳細   : 場合１の入力
                                   a[j] = A[j], 0<j<n
                                   a[0] = A[n]
                               場合２の出力
                                   a[k] = S[k], 0<k<n
                                   a[0] = S[n]

            ip  : ビット反転用作業領域
                      型     : 整数型配列
                      サイズ : 0 から 1+sqrt(n/2) まで(正確には 1+sqrt(n/2)
                               と 1+sqrt(n/4) の割り切れる方まで)
                      詳細   : ip[2...*] が作業領域で，ip[0], ip[1] は表
                               の管理データ(値の変更は不可)である．
            w   : 三角関数表
                      型     : 倍精度実数型配列
                      サイズ : 0 から n*5/4-1 まで
                      詳細   : 三角関数表は ip[0] が 0 のときに初期化さ
                               れる．

        [注意]
            正確には，場合２の逆変換は，a[0] を 1/n 倍，他の a[j] を 2/n
            倍した，場合１の変換である．

    ◆rdftのコサイン変換 :
            C[k] = Σ_j=0^n a[j]*cos(π*j*k/n), 0<=k<=n
        を求める．

        [書式]
            fft2f.cの場合
                dfct(n, cos(M_PI/n), sin(M_PI/n), a);
            fft2f.fの場合
                call dfct(n, cos(pi/n), sin(pi/n), a)
            fft4*.cの場合
                ip[0] = 0; // 二回目以降の呼び出しには不要
                dfct(n, a, t, ip, w);
            fft4*.fの場合
                ip(0) = 0  ! 二回目以降の呼び出しには不要
                call dfct(n, a, t, ip, w)

        [引数]
            n   : データ長 - 1
                      型     : 整数
                      詳細   : n は 2 以上で２のベキ乗に選ぶ．
            a   : 入出力データ
                      型     : 倍精度実数型配列
                      サイズ : 0 から n まで (n-1 までではない)
                      詳細   : 結果: C[k] は a[k] に上書きされる．

            t   : 作業領域
                      型     : 倍精度実数型配列
                      サイズ : 0 から n/2 まで
                      詳細   : 初期化の必要なし．値の変更可．
            ip  : ビット反転用作業領域
                      型     : 整数型配列
                      サイズ : 0 から 1+sqrt(n/4) まで(正確には 1+sqrt(n/4)
                               と 1+sqrt(n/8) の割り切れる方まで)
                      詳細   : ip[2...*] が作業領域で，ip[0], ip[1] は表
                               の管理データ(値の変更は不可)である．
            w   : 三角関数表
                      型     : 倍精度実数型配列
                      サイズ : 0 から n*5/8-1 まで
                      詳細   : 三角関数表は ip[0] が 0 のときに初期化さ
                               れる．

        [参考]
            a[0] と a[n] を 1/2 倍したこの変換は，二回繰り返すと n/2 倍
            されてもとに戻る．

    ◆rdftのサイン変換 :
            S[k] = Σ_j=1^n-1 a[j]*sin(π*j*k/n), 0<k<n
        を求める．

        [書式]
            fft2f.cの場合
                dfst(n, cos(M_PI/n), sin(M_PI/n), a);
            fft2f.fの場合
                call dfst(n, cos(pi/n), sin(pi/n), a)
            fft4*.cの場合
                ip[0] = 0; // 二回目以降の呼び出しには不要
                dfst(n, a, t, ip, w);
            fft4*.fの場合
                ip(0) = 0  ! 二回目以降の呼び出しには不要
                call dfst(n, a, t, ip, w)

        [引数]
            n   : データ長 + 1
                      型     : 整数
                      詳細   : n は 2 以上で２のベキ乗に選ぶ．
            a   : 入出力データ
                      型     : 倍精度実数型配列
                      サイズ : 0 から n-1 まで(a[0] は作業領域)
                      詳細   : 結果: S[k] は a[k] に上書きされる．

            t   : 作業領域
                      型     : 倍精度実数型配列
                      サイズ : 0 から n/2-1 まで
                      詳細   : 初期化の必要なし．値の変更可．
            ip  : ビット反転用作業領域
                      型     : 整数型配列
                      サイズ : 0 から 1+sqrt(n/4) まで(正確には 1+sqrt(n/4)
                               と 1+sqrt(n/8) の割り切れる方まで)
                      詳細   : ip[2...*] が作業領域で，ip[0], ip[1] は表
                               の管理データ(値の変更は不可)である．
            w   : 三角関数表
                      型     : 倍精度実数型配列
                      サイズ : 0 から n*5/8-1 まで
                      詳細   : 三角関数表は ip[0] が 0 のときに初期化さ
                               れる．

        [参考]
            この変換は，二回繰り返すと n/2 倍されてもとに戻る．

    補足:
        データ長 n を２の整数乗以外に選んだ場合の動作は，保証されない．
        三角関数表は，より大きなサイズが必要になった時点で計算される．初
        期化ルーチンを用いれば，必要なだけ表を計算しておくことができる(
        プログラム参照)．w, ip は，すべてのルーチンで互換性がある．


【計算方法】

    ◆cdftについて
        [fft2f.*の場合]
            　基数 2 のSande-Tukey法(周波数間引き)を用いる．Sande-Tukey
            法は，Cooley-Tukey法(時間間引き)に比べて精度が少しよいようで
            ある．バタフライ演算は，三角関数の計算の都合により，一つのル
            ープで二回行う．また，加減算だけでできるバタフライ演算は，分
            けて計算する．
            　三角関数の計算は漸化式:
                cos((k+1)*h) = -(2*sin(h)) * sin(k*h) + cos((k-1)*h), 
                sin((k+1)*h) = (2*sin(h)) * cos(k*h) + sin((k-1)*h)
            により計算する．プログラムでは
                wkr = cos(k*h), 
                wki = sin(k*h), 
                wdr = cos((k+1)*h), 
                wdi = sin((k+1)*h)
            に対応する．計算量は，三角関数一回につき乗算一回，加減算一回
            である．他の漸化式としてChebyshev多項式の漸化式:
                cos((k+1)*h) = (2*cos(h)) * cos(k*h) - cos((k-1)*h)
            が考えられるが，このままでは精度が悪く桁落ち防止用の変形をし
            なければ使えない．
            　ビット反転並べ替えは以下の方法で行う．k~ を k のビット反転
            とすると
                2*j             のビット反転は (2*j)~, 
                n-1 - 2*j       のビット反転は n-1 - (2*j)~, 
                2*j + 1         のビット反転は n/2 + (2*j)~, 
                n-1 - (2*j + 1) のビット反転は n-1 - (n/2 + (2*j)~)
            となり， 0<=j<n/4 の範囲ですべてのビット反転の対ができる(ビ
            ット反転計算を 1/4 に減らせる)．変数の交換は２回重複するので
            右の項が左の項よりも大きくなる場合の対についてのみ交換する．

            <Sande-Tukey法概略(おまけ)>
                まず，長さ n の離散Fourier変換:
                    X[k] = Σ_j=0^n-1 x[j] * W(n)^(j*k), 0<=k<n, 
                        W(n) = exp(2*π*i/n)
                を素直に計算する場合を考えます．この場合 X[0] から X[n-1]
                までの各項の計算に n 回の乗算が必要なため，全体で n^2 回
                の乗算が必要になります．しかし，少し考えてみてください．
                長さ n の離散Fourier変換は，次の二つの，長さ n/2 の離散
                Fourier変換:
                    X[2*k]   = Σ_j=0^n/2-1 
                                      (x[j]+x[n/2+j]) * W(n/2)^(j*k), 
                    X[2*k+1] = Σ_j=0^n/2-1 
                               W(n)^j*(x[j]-x[n/2+j]) * W(n/2)^(j*k), 
                        0<=k<n/2
                に分解できることがわかります．長さ n/2 の離散Fourier変換
                は n^2/4 回の乗算で実行できるので，この分解により，計算
                量は約半分に減ります．さらに，この分解を 2 回, 3 回,...
                と繰り返せば，計算量は約 1/4, 1/8,... と激減します．これ
                がSande-Tukey法によるFFTの基本的な考え方です(Winogradの
                DFT -文献参照- の考え方はこれとは少し異なるので注意)．
                Sande-Tukey法では，この分解(間引き)を長さ 1 の離散Fourier
                変換(無変換)になるまで繰り返し，n^2 のオーダーの計算をす
                べて排除します．このときの計算量は n/2 回の x[j]+x[n/2+j]
                と W(n)^j*(x[j]-x[n/2+j]) の計算(いわゆるバタフライ演算)
                を log(n) 回行う程度(すなわち n*log(n) のオーダー)に減少
                します．
                データを上書きする場合 x[j], x[n/2+j] に X[2*j], X[2*j+1]
                を格納するため，1 つ隣り合うデータが n/2 個隣り合うデー
                タに並べ替えられます(すなわち添字の最初のビットと最後の
                ビットとを交換した順に並びます)．そのため，データの添字
                のビット反転並べ替えが最後に必要になります．

                ちなみにCooley-Tukey法での間引き(時間間引き)は以下のよう
                にします．
                    X[k] =        Σ_j=0^n/2-1 x[2*j] * W(n/2)^(j*k)
                         + W(n)^k*Σ_j=0^n/2-1 x[2*j+1] * W(n/2)^(j*k), 
                    X[n/2+k] =    Σ_j=0^n/2-1 x[2*j] * W(n/2)^(j*k)
                         - W(n)^k*Σ_j=0^n/2-1 x[2*j+1] * W(n/2)^(j*k), 
                            0<=k<n/2

                一般にSande-Tukey法による基数 L の間引きは以下のようにな
                ります．
                    X[L*k]   = Σ_j=0^n/L-1 
                             (x[j]+x[n/L+j]+x[2*n/L+j]+...
                             +x[(L-1)*n/L+j]) * W(n/L)^(j*k), 
                    X[L*k+1] = Σ_j=0^n/L-1 W(n)^j*
                             (x[j]+W(L)*x[n/L+j]+W(L)^2*x[2*n/L+j]+...
                             +W(L)^(L-1)*x[(L-1)*n/L+j]) * W(n/L)^(j*k), 
                    X[L*k+2] = Σ_j=0^n/L-1 W(n)^(2*j)*
                             (x[j]+W(L)^2*x[n/L+j]+W(L)^4*x[2*n/L+j]+...
                             +W(L)^(2*L-2)*x[(L-1)*n/L+j]) * W(n/L)^(j*k), 
                    ...
                        0<=k<n/L
                この分解を log_L(n) 回繰り返すと，乗算回数は log_L(n)*(
                (L-1)+(長さLの離散Fourier変換の乗算数))*n/L となることが
                わかります．したがって，基数 4 の算法は，基数 2 のに比べ
                て乗算回数が 3/4 に減少し，さらに，基数 8 では 2/3 に，
                基数 16 では 5/8 に減少します．

        [fft4*.*の場合]
            　基数 4 の周波数間引きFFTを用いる．ただし，内側のループでメ
            モリアクセスを連続にするため，配列の添字をビット反転する．そ
            のため，三角関数表 w がビット反転し，データのビット反転の順
            序が逆(最後がキャンセルされ最初に付加)になる．n が 4 のベキ
            乗で割り切れないときは，最後に基数 2 のバタフライ演算を付け
            足す．この場合，4 進数のワード反転と 2 進数のビット反転との
            混合を避けるため，基数 4 のバタフライ演算の二番目と三番目の
            入力を入れ換え，常にビット反転になるようにする．
            　三角関数は倍角までは表を引き，三倍角はその場で加法定理より
            計算する．
            　ビット反転並べ替えは以下の方法で行う．k~ を k のビット反転
            とすると
                m = sqrt(n) が整数のとき
                    j~ + k     のビット反転は k~ + j
                m = sqrt(n/2) が整数のとき
                    j~ + k     のビット反転は k~ + j, 
                    j~ + m + k のビット反転は k~ + m + j
            となり， 0<=j<m, 0<=k<m の範囲ですべてのビット反転の対ができ
            る(ビット反転計算を 1/sqrt(n) に減らせる)．変数の交換は２回
            重複するので j<k となる対についてのみ交換する．

    ◆rdftについて
        　cdftに以下のバタフライ演算を一段付加する方法を用いる．順変換:
            A[k] = Σ_j=0^n-1 a[j]*W(n)^(j*k), 0<=k<=n/2, 
                W(n) = exp(2*π*i/n)
        を求める場合，
            x[j] = a[2*j] + i*a[2*j+1], 0<=j<n/2
        として長さ n/2 の複素離散Fourier変換:
            X[k] = Σ_j=0^n/2-1 x[j] * W(n/2)^(j*k), 0<=k<n
        を呼び出す．結果: A[k] は式:
            A[k]     = X[k]     - (1+i*W(n)^k)/2 * (X[k]-conjg(X[n/2-k])), 
            A[n/2-k] = X[n/2-k] + (1+i*W(n)^k)/2 * (X[k]-conjg(X[n/2-k])), 
                0<=k<=n/2  (注: conjg() は複素共役, X[n/2]=X[0] とおく)
        で求めることができる．逆変換はこの計算を逆方向に行う．
        　他の計算法に，実数データのFourier変換の複素共役対称性をうまく
        利用して，複素FFTのバタフライ演算のみで計算する方法がある．この
        方法は，順変換を時間間引き演算，逆変換を周波数間引き演算で行うの
        で，二つのルーチンが必要になる．この方法は，メモリアクセスが複雑
        になるため，実行時間が遅くなることがある．
        　もう一つの計算法に(あまり知られてない？)，三角関数の添字が 1/2
        ずれた離散Fourier変換(いわゆる離散コサイン/サイン変換)を再帰的に
        用いて計算する方法がある(dfct/dfst参照)．離散コサイン/サイン変換
        は，非常に対称性がよいため，複素FFTのバタフライ演算のみで計算す
        る場合，メモリアクセスが複雑になることはない．

    ◆ddctについて
        　rdftに以下の演算を付加する方法を用いる．逆変換:
            C[k] = Σ_j=0^n-1 a[j]*cos(π*j*(k+1/2)/n), 0<=k<n
        を求める場合，
            r[0] = a[0], 
            r[j]   = Re((a[j] - i*a[n-j]) * W(4*n)^j*(1+i)/2), 
            r[n-j] = Im((a[j] - i*a[n-j]) * W(4*n)^j*(1+i)/2), 
                0<j<=n/2
        として長さ n の実離散Fourier変換:
            A[k] = Σ_j=0^n-1 r[j]*W(n)^(j*k), 0<=k<=n/2, 
                W(n) = exp(2*π*i/n)
        を呼び出す．結果: C[k] は式:
            C[2*k]   =  Re(A[k] * (1-i)), 
            C[2*k-1] = -Im(A[k] * (1-i))
        で求めることができる．順変換はこの計算を逆方向に行う．
        　他の計算法に，対称性をうまく利用して，複素FFTのバタフライ演算
        のみで計算する方法がある(文献参照)．

    ◆ddstについて
        　rdftに以下の演算を付加する方法を用いる．逆変換:
            S[k] = Σ_j=1^n A[j]*sin(π*j*(k+1/2)/n), 0<=k<n
        を求める場合，
            r[0] = a[0], 
            r[j]   = Im((a[n-j] - i*a[j]) * W(4*n)^j*(1+i)/2), 
            r[n-j] = Re((a[n-j] - i*a[j]) * W(4*n)^j*(1+i)/2), 
                0<j<=n/2
        として長さ n の実離散Fourier変換:
            A[k] = Σ_j=0^n-1 r[j]*W(n)^(j*k), 0<=k<=n/2, 
                W(n) = exp(2*π*i/n)
        を呼び出す．結果: S[k] は式:
            S[2*k]   =  Re(A[k] * (1+i)), 
            S[2*k-1] = -Im(A[k] * (1+i))
        で求めることができる．順変換はこの計算を逆方向に行う．
        　他の計算法に，対称性をうまく利用して，複素FFTのバタフライ演算
        のみで計算する方法がある(文献参照)．

    ◆dfctについて
        　間引きによりddctの計算に分解する方法を用いる．変換:
            C[k] = Σ_j=0^n a[j]*cos(π*j*k/n), 0<=k<=n
        は，長さ n/2 のddctと長さ n/2 のdfct:
            C[2*k]   = Σ'_j=0^n/2  (a[j]+a[n-j])*cos(π*j*k/(n/2)), 
            C[2*k+1] = Σ_j=0^n/2-1 (a[j]-a[n-j])*cos(π*j*(k+1/2)/(n/2))
        とに分解できる(Σ' は最後の項を 1/2 倍する)．この分解をddctの長
        さが 1 になるまで繰り返す．
        　データの並べ替えは，fft2f.*の場合はビット反転並べ替えを用い，
        fft4*.*の場合は作業用配列を用いる．

    ◆dfstについて
        　間引きによりddstの計算に分解する方法を用いる．変換:
            S[k] = Σ_j=1^n-1 a[j]*sin(π*j*k/n), 0<k<n
        は，長さ n/2 のddstと長さ n/2 のdfst:
            S[2*k]   = Σ_j=1^n/2-1 (a[j]-a[n-j])*sin(π*j*k/(n/2)), 
            S[2*k+1] = Σ'_j=1^n/2  (a[j]+a[n-j])*sin(π*j*(k+1/2)/(n/2))
        とに分解できる(Σ' は最後の項を 1/2 倍する)．この分解をddstの長
        さが 1 になるまで繰り返す．
        　データの並べ替えは，fft2f.*の場合はビット反転並べ替えを用い，
        fft4*.*の場合は作業用配列を用いる．


【その他】

    ◆参考文献
        森正武,名取亮,鳥居達生: 数値計算, 岩波講座情報科学18, 岩波書店, 
        1982
            ---- 複素FFTのバタフライ演算を用いる，高速離散コサイン変換の
            アルゴリズムが掲載されている ----
        
        Henri J. Nussbaumer: Fast Fourier Transform and Convolution 
        Algorithms, Springer Verlag, 1982
            ---- 通常のFFTより高速な，素数分割によるFFTや，Winograd算法
            によるDFTのアルゴリズムが掲載されている ----

    ◆著作/連絡先
        大浦拓哉 (email: ooura@mmm.t.u-tokyo.ac.jp)

    ◆編集履歴
        ...
        1995年12月 : サイズを縮小し，汎用版を作成．
        1996年3月  : 汎用版の仕様を変更．
        1996年6月  : 三角関数表の計算法を変更(精度が良くなった)．
        1996年9月  : ドキュメントの修正．
        1997年2月  : バタフライループの変更(少し速くなったかも?)．
        1997年12月 : ドキュメントの修正．
        1997年12月 : 高速版の作成．

