/*
 * Copyright 1997-2003 Samuel Audet <guardia@step.polymtl.ca>
 *                     Taneli Lepp„ <rosmo@sektori.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 *    3. The name of the author may not be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 File handling for reading and writing MP3-TAG, a format by Damaged
 Cybernetics.
 *
 Source by Thorvald Natvig
 */

#define INCL_BASE
#define INCL_PM
#include <os2.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include "tag.h"
#include "pm123.h"

/* This one includes the table of the genres. Autogenerated */
#include "genre.h"


/* fetch string from MP3 tag */
static void safecopy(char *to, const char *from, int maxlen) {
   int where;
   strncpy(to,from,maxlen);
   to[maxlen]=0;
   for ( where=maxlen-1 ; ((where>=0) && (to[where]==' ')) ; where-- ) {
      to[where]=0 ;
   }
}

/* store string to mp3 tag */
static void spacecopy(char *to, const char *from, int maxlen) {
   int where;
   strncpy(to,from,maxlen);
   for ( where=maxlen-1 ; ((where>=0) && (to[where]==0)) ; where--) {
      to[where]=' ';
   }
}

void emptytag(tune* info)
{  memset(info, 0, sizeof *info);
   // well unfortunately the default genre is not zero
   info->gennum = -1;
}

int wipetag(int fd) {
   char buffer[4];
   long filesize;
   lseek(fd,-128,SEEK_END);
   filesize = tell(fd);
   read(fd,&buffer,3);
   if (! strncmp(buffer,"TAG",3)) {
      lseek(fd,0,SEEK_SET);
      if(chsize(fd,filesize)==0)
         return(1);
      else return(0);
   } else {
      return(1);
   }
}


int gettag(int fd, tune *info) {
   tag song;
   lseek(fd, -128, SEEK_END) ;
   read(fd, &song, 128);
   
   if (! strncmp(song.tag,"TAG",3)) {
      safecopy(info->title,song.title,30);
      safecopy(info->artist,song.artist,30);
      safecopy(info->album,song.album,30);
      safecopy(info->year,song.year,4);
      if (song.u_comtrk.V1_1.spacer == 0 && song.u_comtrk.V1_1.track != 0)
      {  // ID3 V1.1 tag
         safecopy(info->comment, song.u_comtrk.V1_1.comment, sizeof song.u_comtrk.V1_1.comment);
         info->track = song.u_comtrk.V1_1.track;
      } else
      {  safecopy(info->comment, song.u_comtrk.V1_0.comment, 30);
         info->track = 0;
      }
      info->gennum = song.genre == 0xFF ? -1 : song.genre;
      strcpy(info->genre,genres[song.genre >= GENRE_LARGEST ? GENRE_LARGEST : song.genre]);
      return(1);
   } else {
      return(0);
   }
}

/* Function removed because buggy and unused
void jointag(tune *to, tune *from) {
   if (from->title[0]) strncpy(to->title,from->title,30);
   if (from->artist[0]) strncpy(to->artist,from->artist,30);
   if (from->album[0]) strncpy(to->album,from->album,30);
   if (from->year[0]) strncpy(to->year,from->year,4);
   if (from->comment[0]) strncpy(to->comment,from->comment,30);
   if (from->gennum != -1 ) to->gennum=from->gennum;
   // TODO: don't change gennums that PM123 does not know 
   if (to->gennum >= GENRE_LARGEST) {
      to->gennum = GENRE_LARGEST;
   }
   // TODO: we should keep the string 
   strcpy(to->genre,genres[to->gennum]);
}*/

int settag(int fd, const tune *info) {
   int temp;
   tag song;

   spacecopy(song.title,info->title,30);
   spacecopy(song.artist,info->artist,30);
   spacecopy(song.album,info->album,30);
   spacecopy(song.year,info->year,4);
   if (info->track > 0 && info->track < 256)
   {  // Write ID3 V1.1 tag 
      spacecopy(song.u_comtrk.V1_1.comment, info->comment, sizeof song.u_comtrk.V1_1.comment);
      song.u_comtrk.V1_1.spacer = 0;
      song.u_comtrk.V1_1.track = (unsigned char)info->track;
   } else
   {  // Write ID3 V1.0 tag
      spacecopy(song.u_comtrk.V1_0.comment, info->comment, sizeof song.u_comtrk.V1_0.comment);
   }

   // Don't write unreasonable values, but keep genres that PM123 does not know
   // and don't make them to Blues.
   song.genre = info->gennum < 0 || info->gennum > 0xFF
      ? 0xFF
      : (unsigned char)info->gennum; 

   lseek(fd, -128, SEEK_END) ;
   temp=read(fd, &song, 3) ;
   if (! strncmp(song.tag,"TAG",3)) {
      lseek(fd, -128, SEEK_END) ;
   } else {
      lseek(fd, 0 , SEEK_END) ;
   }
   strncpy(song.tag,"TAG",3);
   temp=write(fd,&song,128);
   if (temp==128) {
      return (1) ;
   } else {
      return (0) ;
   }
}

/* unused
void printgenres() {
  int i;
  for (i=0; i<=GENRE_LARGEST;i++) {
    printf("%2i : %s\n",i,genres[i]);
  }
}
*/

