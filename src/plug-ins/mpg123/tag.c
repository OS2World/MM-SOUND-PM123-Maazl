/*
 * Copyright 1997-2003 Samuel Audet <guardia@step.polymtl.ca>
 *                     Taneli Lepp„ <rosmo@sektori.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 *    3. The name of the author may not be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 File handling for reading and writing MP3-TAG, a format by Damaged
 Cybernetics.
 *
 Source by Thorvald Natvig
 */

#define INCL_BASE
#define INCL_PM
#include <os2.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <xio.h>
#include "tag.h"

/* This one includes the table of the genres. Autogenerated */
#include "genre.h"

#include <debuglog.h>

/* MP3 ID3 V1.x structure, for intermal use only */
typedef struct {
   char tag[3] ;
   char title[30] ;
   char artist[30] ;
   char album[30] ;
   char year[4] ;
   union      // comment and track
   {  struct  // ID3 V1.0
      {  char comment[30] ;
      } V1_0;
      struct  // ID3 V1.1
      {  char comment[28] ;
         char spacer ;
         unsigned char track ;
      } V1_1;
   }    u_comtrk ;
   unsigned char genre ;
} tag ;


/* fetch string from MP3 tag */
static void safecopy(char *to, const char *from, int maxlen) {
   int where;
   strncpy(to,from,maxlen);
   to[maxlen]=0;
   for ( where=maxlen-1 ; ((where>=0) && (to[where]==' ')) ; where-- ) {
      to[where]=0 ;
   }
}

/* store string to mp3 tag */
static void spacecopy(char *to, const char *from, int maxlen) {
   int where;
   strncpy(to,from,maxlen);
   for ( where=maxlen-1 ; ((where>=0) && (to[where]==0)) ; where--) {
      to[where]=' ';
   }
}

void emptytag(tune* info)
{  memset(info, 0, sizeof *info);
   // well unfortunately the default genre is not zero
   info->gennum = -1;
}

int wipetag(XFILE* x) {
/* Due to restrictions of the xio library we can no longer remove tags! */
   tag song;
   DEBUGLOG(("mpg123:wipetag(%p)\n", x));

   memset( &song, 0, sizeof song );
   //memcpy( song.tag, "TAG", 3 ); not required
   song.genre = 0xFF;

   if( xio_fseek( x, -128, XIO_SEEK_END ) == 0 &&
       xio_fread( song.tag, 1, 3, x ) == 3 ) {
      if( strncmp( song.tag, "TAG", 3 ) == 0 ) {
         if( xio_fwrite(&song.title, 1, 125, x ) == 125 ) {
            return 1;
         }
      } else {
         if( xio_fseek( x, 0, XIO_SEEK_END ) == 0 ) {
            if( xio_fwrite( &song, 1, 128, x ) == 128 ) {
               return 1;
            }
         }
      }
   }
   return 0;
}

int gettag(XFILE* x, tune *info) {
   tag song;
   if( xio_fseek( x, -128, XIO_SEEK_END ) != 0 ||
       xio_fread( &song, 1, 128, x ) != 128 ||
       strncmp( song.tag, "TAG", 3 ) != 0 ) {
      return 0;
   }

   DEBUGLOG(("mpg123:gettag(%p, %p) - %.128s\n", x, info, &song));

   safecopy(info->meta.title,  song.title,  30);
   safecopy(info->meta.artist, song.artist, 30);
   safecopy(info->meta.album,  song.album,  30);
   safecopy(info->meta.year,   song.year,    4);
   if (song.u_comtrk.V1_1.spacer == 0 && song.u_comtrk.V1_1.track != 0)
   {  // ID3 V1.1 tag
      safecopy(info->meta.comment, song.u_comtrk.V1_1.comment, sizeof song.u_comtrk.V1_1.comment);
      info->meta.track = song.u_comtrk.V1_1.track;
   } else
   {  safecopy(info->meta.comment, song.u_comtrk.V1_0.comment, 30);
      info->meta.track = 0;
   }
   info->gennum = song.genre == 0xFF ? -1 : song.genre;
   strcpy(info->meta.genre, genres[song.genre >= GENRE_LARGEST ? GENRE_LARGEST : song.genre]);
   return(1);
}

int settag(XFILE* x, const tune *info) {
   tag song;

   spacecopy(song.title,  info->meta.title,  30);
   spacecopy(song.artist, info->meta.artist, 30);
   spacecopy(song.album,  info->meta.album,  30);
   spacecopy(song.year,   info->meta.year,    4);
   if (info->meta.track > 0 && info->meta.track < 256)
   {  // Write ID3 V1.1 tag
      spacecopy(song.u_comtrk.V1_1.comment, info->meta.comment, sizeof song.u_comtrk.V1_1.comment);
      song.u_comtrk.V1_1.spacer = 0;
      song.u_comtrk.V1_1.track = (unsigned char)info->meta.track;
   } else
   {  // Write ID3 V1.0 tag
      spacecopy(song.u_comtrk.V1_0.comment, info->meta.comment, sizeof song.u_comtrk.V1_0.comment);
   }

   // Don't write unreasonable values, but keep genres that PM123 does not know
   // and don't make them to Blues.
   song.genre = info->gennum < 0 || info->gennum > 0xFF
      ? 0xFF
      : (unsigned char)info->gennum;

   if( xio_fseek( x, -128, XIO_SEEK_END ) == 0 &&
       xio_fread( song.tag, 1, 3, x ) == 3 ) {
      if( strncmp( song.tag, "TAG", 3 ) == 0 ) {
         if( xio_fwrite(&song.title, 1, 125, x ) == 125 ) {
            return 1;
         }
      } else {
         if( xio_fseek( x, 0, XIO_SEEK_END ) == 0 ) {
            if( xio_fwrite( &song, 1, 128, x ) == 128 ) {
               return 1;
            }
         }
      }
   }
   return 0;
}

/* unused
void printgenres() {
  int i;
  for (i=0; i<=GENRE_LARGEST;i++) {
    printf("%2i : %s\n",i,genres[i]);
  }
}
*/
