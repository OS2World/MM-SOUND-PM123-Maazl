<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
  <head>
    <meta content="text/html; charset=windows-1252" http-equiv="content-type">
    <title>Decoder Plugins</title>
    <link rel="stylesheet" href="../common/infstyle.css" type="text/css">
  </head>
  <body>
    <h1>PM123 Decoder Plugins</h1>
    <p>Decoder plugins must implement and export the functions defined in <tt>decoder_plug.h</tt>.</p>
    <p>There are two interface revision levels. For developing new plugins the <strong><a
          href="#level_3">level 3 interface</a> is strongly recommended</strong>.
      But <a href="decoder_plug_1.html">level
        0/1 plugins</a> are still supported. The level 2 of PM123 1.40 is
      discontinued.</p>
    <p>Decoder plugins are used to <em>decode audio data</em> as well as to <em>examine
        playlists</em>. Each item is identified by an URI.<br>
      You should not take the term 'playlist' too literally. It only means that
      an URI has logically a sequence of sub URIs, i.e. the URI has to be
      enumerable. This applies to a playlist as well as to a file system folder
      or&nbsp;a compact disc containing tracks.<br>
      In theory an item could be enumerable as well as directly playable. E.g.
      index tracks of a CD or a CUE sheet. But this has not been well tested in
      the PM123 core so far. </p>
    <h2><a name="level_3"></a>Interface revision level 3 (recommended)</h2>
    <p>The level 3 interface has the following components:</p>
    <ol>
      <li><a href="#playback_interface">Playback interface</a>, <a href="#status_interface">status
          interface</a> and <a href="#output_interface">output interface</a><br>
        This interfaces are used to play audio data. <em>Plugins that only
          support playlists do not need to export these interfaces.</em></li>
      <li><a href="#info_interface">Info interface</a>, <a href="#save_interface">save
          interface</a><br>
        This interface is used to obtain or change information of a song or a
        playlist and to identify whether an item is supported by the plugin.</li>
      <li><a href="#GUI_interface">GUI enhancement interface</a></li>
    </ol>
    <h3><a name="info_interface"></a>Info interface</h3>
    <p>The info interface functions must be independent of the current decoder
      status. They should always be functional and give consistent results in
      any conditions. The functions must be <em>thread safe</em>.</p>
    <h4><a name="decoder_support"></a>decoder_support</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_support</b>(const <a href="decoder_plug.html#DECODER_FILETYPE">DECODER_FILETYPE</a>** <var>types</var>, int* <var>count</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>types</var></code>&nbsp;(out) - Pointer to the first
        element of an array of supported file types.</li>
      <li><var><code>count</code></var>&nbsp;(out) - Number of entries in the
        above array.</li>
      <li><var>return value</var> - return what kind of stream can the decoder
        play:<br>
        <tt> DECODER_FILENAME</tt> (1) - Decoder can play files (including UNC
        names).<br>
        <tt> DECODER_URL</tt> (2) - Decoder can play internet URIs (http, ftp,
        etc.).<br>
        <tt> DECODER_TRACK</tt> (4) - Decoder can play CD tracks, i.e. cdda
        URIs.<br>
        <tt> DECODER_OTHER</tt> (8) - Decoder can play something else.<br>
        <tt>DECODER_SONG</tt> (0x0100) - Decoder can play songs.<br>
        <tt>DECODER_PLAYLIST</tt> (0x0200) - Decoder can read playlists.<br>
        <tt>DECODER_WRITABLE</tt> (0x1000) - Decoder can save items.<br>
        <tt>DECODER_METAINFO</tt> (0x2000) - Decoder can save meta info.<br>
        The values should be ored as required.</li>
    </ul>
    <p>This is used by PM123 to suggest to the user what he can play with the
      decoder. Furthermore, by default <em>PM123 will not query the decoder
        about files or other objects that are not listed in the above filter
        list</em> to keep performance up. </p>
    <p>The function is called again after a successful call to <a href="index.html#plugin_configure"><tt>plugin_configure</tt></a>.
      This allows to modify the supported file types through the configuration.</p>
    <h4><a name="decoder_fileinfo"></a>decoder_fileinfo</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_fileinfo</b>(const char *<var>url</var>, XFILE* <var>handle</var>, int* <var>what</var>, const <a
href="datatype.html#INFO_BUNDLE">INFO_BUNDLE</a>* <var>info</var>,<br>                              &nbsp; <a
href="decoder_plug.html#DECODER_INFO_ENUMERATION_CB">DECODER_INFO_ENUMERATION_CB</a> <var>cb</var>, void* <var>param</var>)</pre>
    </blockquote>
    <ul>
      <li><tt><var>url</var></tt> - URL to the desired stream. See <a href="decoder_plug.html#url_samples">URL
          samples</a>.</li>
      <li><var><tt>handle</tt></var> - optional XIO object handle. If the core
        engine can open the object via XIO then it passes the handle to the
        decoder to avoid that every decoder opens the object anew only to find
        out that it does not support it. The handle is opened in binary read
        only mode with deny none and with synchronous buffering enabled. Even if
        the source stream does not support seeking, you may seek within one
        buffer size. The buffer size depends on the protocol. It it at least
        4kiB, so you should not read more than the first 4kiB.<br>
        Decoders should use this handle unless they have a good reason not to do
        so. <em>Decoders must not close the handle</em>. Only decoders that
        returned <tt>DECODER_OTHER</tt> at <tt>decoder_support</tt> may be
        called with <tt><var>handle</var> == NULL</tt>.</li>
      <li><tt><var>what</var></tt> (in/out) - Bit vector of <a href="datatype.html#INFOTYPE"><tt>INFOTYPE</tt></a>.
        The requested fields in <a href="datatype.html#INFO_BUNDLE"><tt>INFO_BUNDLE</tt></a>.<br>
        The decoder may return more information than requested if it is cheap to
        do so. In this case it should set the additional bits in <tt>*<var>what</var></tt>
        to notify PM123 that the desired information is valid too.<br>
        The decoder <em>must not return less information</em> than requested.
        However, some information may not have any content for the desired
        object. In this case there is no need to modify the appropriate fields
        in <tt>*<var>info</var></tt>.<br>
        If <tt>*<var>what</var></tt> is <tt>0</tt> on input, the information
        in <tt>INFO_BUNDLE</tt> is not required at all. Only the return value
        of <tt>decoder_fileinfo</tt> is used. However, the decoder may return
        more even in this case.</li>
      <li><tt><var>info</var></tt> (out) - this structure must be filled at
        least with the information required by <tt>*<var>what</var></tt>.&nbsp;See
        <tt><a href="datatype.html#INFO_BUNDLE"><tt>INFO_BUNDLE</tt></a></tt>
        for further details. All entries of <tt>INFO_BUNDLE</tt> point to the
        appropriate structures when <tt>decoder_fileinfo</tt> is called.<br>
        If some information is not available, the requested fields in <tt>INFO_BUNDLE</tt>
        should be left unchanged. Normally all fields have their initial value.
        But the <tt>TECH_INFO</tt> sub structure could contain some format
        information from a playlist plugin or an earlier call. This could be
        used to read raw PCM files.<br>
        If the handle parameter is not NULL, the PHYS_INFO structure is already
        filled with the appropriate values.<br>
        Note, that leaving fields initial is different from unrequested
        informations where the corresponding bits in <tt>*<var>what</var></tt>
        are not set. In the latter case the information <em>might</em> become
        available later on request. It is just not yet known.<br>
        In case of an error (non-zero return value) the decoder should return an
        error text in the <tt>tech-&gt;info</tt> field, if available.</li>
      <li><code><var>cb</var></code> - Callback function.<br>
        If <tt>INFO_OTHER</tt> is requested, the decoder has to call this
        function once for each item in the playlist (or collection) before <code>decoder_fileinfo</code>
        returns. Of course, this does not apply to songs.</li>
      <li><code><var>param</var></code> - This parameter is to be passed as
        first argument to each call to <code>*<var>cb</var></code>.</li>
      <li><var>return value</var> -<br>
        <tt> PLUGIN_OK</tt> (<tt>0</tt>) = everything's perfect, structure is
        set.<br>
        <tt> PLUGIN_NO_READ</tt> (<tt>100</tt>) = error reading file. <em>This
          error should only be set if there is no chance that any other plugin
          may read this URL.</em> E.g. if it is a file URI and the file does not
        exist or if it is a http URI and the domain does not exist or the server
        does not respond on the port. In fact decoders normally shall not return
        <tt> PLUGIN_NO_READ</tt> if they are called with a valid <var><tt>handle</tt></var>.<br>
        <tt> PLUGIN_NO_PLAY</tt> (<tt>200</tt>) = this decoder can't play that.
        PM123 will try other decoders if available.</li>
    </ul>
    <table border="1" cellpadding="3" cellspacing="0">
      <tbody>
        <tr>
          <th>bit in <tt>*<var>what</var></tt> on input</th>
          <th>bit in <tt>*<var>what</var></tt> on return</th>
          <th>corresponding info available</th>
          <th>corresponding fields in&nbsp;<tt>INFO_BUNDLE</tt></th>
        </tr>
        <tr>
          <td align="center">reset</td>
          <td align="center">reset</td>
          <td align="center">don't care</td>
          <td>ignored</td>
        </tr>
        <tr>
          <td align="center">set</td>
          <td align="center">reset</td>
          <td align="center">don't care</td>
          <td><strong>not allowed!</strong></td>
        </tr>
        <tr>
          <td align="center">don't care</td>
          <td align="center">set</td>
          <td align="center">no</td>
          <td>leave unmodified</td>
        </tr>
        <tr>
          <td align="center">don't care</td>
          <td align="center">set</td>
          <td align="center">yes</td>
          <td>fill with valid content</td>
        </tr>
      </tbody>
    </table>
    <p>If a decoder knows that some information, that is not explicitly
      requested, is not available for the current URI or it knows it's content
      during processing of the request, it should always set the corresponding
      bit in <tt>*<var>what</var></tt> and return the information if
      applicable. This avoids redundant calls to <tt>decoder_fileinfo</tt>.</p>
    <p>PM123 does not need all informations for all kind of objects. <em>The
        aggregate type recursive playlist information is never requested
        explicitly by PM123.</em> PM123 will also never request <tt>INFO_PHYS</tt>
      if a <var><tt>handle</tt></var> is not <tt>NULL</tt>. However, a plugin
      may supply aggregate information if it is available. E.g. playlists may
      store cached information about their children to improve performance. If
      you are in doubt, do not supply this kind of information.</p>
    <p style="float: right;"><u>Legend:</u><br>
      <strong>X</strong> = required if requested by the PM123<br>
      Q = may be requested by the PM123<br>
      <em>C</em>&nbsp;= my be cached and returned by the decoder<br>
      O = may be overridden by a playlist item </p>
    <p style="float: right;"> </p>
    <table border="1" cellpadding="3" cellspacing="0">
      <tbody>
        <tr>
          <th>info type</th>
          <th>song</th>
          <th>playlist</th>
          <th>playlist item</th>
        </tr>
        <tr>
          <td><code>phys</code></td>
          <td align="center"><strong>X</strong> </td>
          <td align="center"><strong>X</strong> </td>
          <td align="center"><em></em><em>C</em></td>
        </tr>
        <tr>
          <td><code>tech</code></td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><em>C</em></td>
        </tr>
        <tr>
          <td><code>obj</code></td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><em>C</em></td>
        </tr>
        <tr>
          <td><code>meta</code></td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><em>C</em> O</td>
        </tr>
        <tr>
          <td><code>attr</code></td>
          <td align="center">Q</td>
          <td align="center"><strong>X</strong></td>
          <td align="center"><em>C</em> O</td>
        </tr>
        <tr>
          <td>children</td>
          <td align="center">Q</td>
          <td align="center"><strong>X</strong></td>
          <td> <br>
          </td>
        </tr>
        <tr>
          <td><code>rpl</code></td>
          <td>&nbsp;</td>
          <td align="center"><em>C</em><em></em></td>
          <td align="center"><em>C</em></td>
        </tr>
        <tr>
          <td><tt>drpl</tt></td>
          <td>&nbsp;</td>
          <td align="center"><em>C</em><em></em></td>
          <td align="center"><em>C</em></td>
        </tr>
        <tr>
          <td><tt>item</tt></td>
          <td> <br>
          </td>
          <td> <br>
          </td>
          <td align="center">O</td>
        </tr>
      </tbody>
    </table>
    <br>
    <h5><a name="DECODER_INFO_ENUMERATION_CB"></a>DECODER_INFO_ENUMERATION_CB</h5>
    <blockquote>
      <pre>void (DLLENTRY* <b>cb</b>)(void* <var>param</var>, const char* <var>url</var>, const <a
href="datatype.html#INFO_BUNDLE">INFO_BUNDLE</a>* <var>info</var>,&nbsp;int <var>cached</var>, int <var>reliable</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>param</var></code> - Arbitrary parameter from&nbsp;<code>decoder_fileinfo</code>.</li>
      <li><code><var>url</var></code> - URI of the sub item. The URI may be
        absolute or relative. In case of relative URIs the context of the
        enclosing playlist is used for URI resolution.</li>
      <li><code><var>info</var></code> - Known information about the sub item.
        If you already know some information about an item, you should place it
        in <code>*<var>info</var></code>. This can make PM123 significantly
        faster. If you do not have any information, you can pass <code>NULL</code>
        as <code><var>info</var></code>.</li>
      <li><code><var>cached, reliable</var></code> - Two bit vectors of <tt><a
            href="datatype.html#INFOTYPE"><tt>INFOTYPE</tt></a></tt>
        corresponding to fields in <tt>*<var>info</var></tt>.<br>
        <table border="1" cellpadding="3" cellspacing="0">
          <tbody>
            <tr>
              <th><var><tt>cached</tt></var></th>
              <th><var><tt>reliable</tt></var></th>
              <th>Corresponding field in <tt>*<var>info</var></tt> contains</th>
            </tr>
            <tr>
              <td align="center" valign="top">0</td>
              <td align="center" valign="top">0</td>
              <td valign="top">- ignored -, may be <tt>NULL</tt></td>
            </tr>
            <tr>
              <td align="center" valign="top">1</td>
              <td align="center" valign="top">0</td>
              <td valign="top">The field contain <i>cached</i> information that
                might no longer be valid.</td>
            </tr>
            <tr>
              <td align="center" valign="top">0</td>
              <td align="center" valign="top">1</td>
              <td valign="top">The field contains <i>reliable</i> information
                that just had been verified.</td>
            </tr>
            <tr>
              <td align="center" valign="top">1</td>
              <td align="center" valign="top">1</td>
              <td valign="top">The field contains information that is <i>overridden
by
this
                  reference</i> only.</td>
            </tr>
          </tbody>
        </table>
        You may use overridden information e.g. to give meaningful meta
        information to a slice of an object. For example a cue sheet may
        reference slices of a long file, but the slices have different meta
        information although the underlying object is the same. You cannot
        override all kind of information. See the above matrix for details.</li>
    </ul>
    <h3><a name="playback_interface"></a>Playback interface</h3>
    <h4>decoder_init, decoder_uninit</h4>
    <blockquote>
      <pre>int DLLENTRY <b>decoder_init</b> (struct DECODER_STRUCT **<var>w</var>)</pre>
    </blockquote>
    <ul>
      <li><tt><var>w</var></tt> - Allocate any chunk of memory necessary for the
        decoder's function. This pointer will be passed to the other functions.
        The type <tt>struct DECODER_STRUCT</tt> is incomplete. You may fill it
        with life or simply cast to your own type.</li>
      <li>return value:<br>
        <tt>PLUGIN_OK</tt> (<tt>0</tt>) means success.<br>
        <tt>PLUGIN_FAILED</tt> (<tt>-1</tt>) means the decoder was not
        initialized successfully.</li>
    </ul>
    The <tt>decoder_init</tt> function is called when PM123 needs the specified
    decoder to play the stream demanded by the user. So only one decoder plugin
    is active at any given time. It should initialize the necessary semaphores
    and threads.
    <blockquote>
      <pre>BOOL DLLENTRY <b>decoder_uninit</b>(struct DECODER_STRUCT *<var>w</var>)</pre>
    </blockquote>
    <ul>
      <li><tt><var>w</var></tt> - The pointer received by <tt>decoder_init</tt>.
      </li>
      <li>return value: <tt>TRUE</tt> = success</li>
    </ul>
    <p><code>decoder_uninit</code> is called when another decoder than yours is
      needed, and should destroy the decoder's thread, semaphores, other opened
      handles and free allocated memory for <tt><var>w</var></tt>. The decoder
      must not execute any callback function like <a href="#OutRequestBuffer"><tt>OutRequestBuffer</tt></a>
      from another thread when <tt>decoder_uninit</tt> has returned.</p>
    <h4><a name="decoder_command"></a>decoder_command</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_command</b>(struct DECODER_STRUCT *<var>w</var>, ULONG <var>msg</var>, DECODER_PARAMS2 *<var>params</var>)</pre>
    </blockquote>
    <ul>
      <li><tt><var>msg</var></tt> - one of the following:
        <ul>
          <li><tt>DECODER_SETUP</tt> - setup various parameters such as the
            output plugin functions.</li>
          <li><tt>DECODER_PLAY</tt> - start playing the given filename, URL or
            others.</li>
          <li><tt>DECODER_FFWD</tt> - engage in ffwd mode (i.e.: play faster or
            skip forward or backward when playing).</li>
          <li><tt>DECODER_JUMPTO</tt> - jump and start decoding at the given
            time position.</li>
          <li><tt>DECODER_SAVEDATA</tt> - tells the decoder to start saving the
            stream to HD.</li>
          <li><tt>DECODER_STOP</tt> - stop playing.</li>
        </ul>
      </li>
      <li><tt><var>params</var></tt> - structure that contains the parameters
        needed by the preceding commands.</li>
      <li>return value:<br>
        <tt>PLUGIN_OK</tt> (<tt>0</tt>) -&gt; ok.<tt> <br>
          PLUGIN_UNSUPPORTED (</tt><tt>1) -&gt; command u</tt>nsupported.<br>
        <tt>DECODER_PLAY</tt> and <tt>DECODER_STOP</tt> can return also <tt>PLUGIN_GO_ALREADY</tt>
        (<tt>101</tt>) and <tt>PLUGIN_GO_FAILED</tt> (<tt>102</tt>).</li>
    </ul>
    <p>There are a lot of commands to implement for this function. Parameters
      needed for each of them are passed in the <a href="decoder_command.html#DECODER_PARAMS2"><tt>DECODER_PARAMS2</tt></a>
      structure and described in detail <a href="decoder_command.html">here</a>
      and in the <tt>decoder_plug.h</tt> include. The decoder necessarily
      should support following commands: <tt>DECODER_SETUP</tt>, <tt>DECODER_PLAY</tt>
      and <tt>DECODER_STOP</tt>.</p>
    <p><a name="url_samples"></a>In the level 3 interface the data source always
      passed as an URL. The URL parameter uses the following syntax:</p>
    <blockquote><samp>file:///D:/Music/my favorite song.mp3</samp><br>
      <samp>file://server/share/path/song.mp3 </samp>(UNC path)<br>
      <samp>http://... </samp>(as you would expect)<br>
      <samp>cdda:///H:/track02</samp> (CD track)<br>
      <samp>cdda:///H:/</samp> (CD TOC) </blockquote>
    <h5><tt>DECODER_SETUP</tt></h5>
    <blockquote>The <tt><tt>DECODER_SETUP</tt></tt> call is intended to capture
      the callback entries for the <a href="#output_interface">output interface</a>.
      They do not change during decoding.</blockquote>
    <h5><tt>DECODER_PLAY</tt></h5>
    <blockquote>
      <p>This command tell the decoder which song to decode. This should spawn a
        new thread that decodes the song and feeds the result to the <a href="#output_interface">output
          interface</a>.</p>
    </blockquote>
    <h5><tt>DECODER_JUMPTO</tt></h5>
    <blockquote>
      <p>Tells the decoder to continue decoding at a certain location of the
        song. The structure member <tt>JumpTo</tt> is the location in seconds
        from the song's start.</p>
    </blockquote>
    <h5><tt>DECODER_FFWD</tt></h5>
    <blockquote>
      <p>Change the fast forward or rewind mode. The structure member <tt>SkipSpeed</tt>
        tell the decoder which playback speed is intended. The value i a delta
        to the normal playback speed, i.e. <var>speed</var> = <var><tt>SkipSpeed</tt></var>
        + 1. Examples:</p>
      <ul>
        <li><b>0.0</b> =&gt; normal playback</li>
        <li>1.0 =&gt; play twice as fast</li>
        <li><b>3.0</b> =&gt; play 4 times faster</li>
        <li>-2.0 =&gt; play reverse</li>
        <li>-3.0 =&gt; play reverse twice as fast</li>
        <li><b>-5.0</b> =&gt; play revers 4 time faster</li>
        <li>-0.5 =&gt; play at half speed (currently unused)</li>
      </ul>
      <p>There is no need to hit this value exactly. It is better to skip parts
        of the song instead of transforming the sample rate. Common values are
        marked bold. If a decoder can't support different speeds, it could
        simply use <tt>SkipSpeed</tt> &gt; 0 for fast forward, and <tt>SkipSpeed</tt>
        &lt; 0 for fest rewind.</p>
      <p><u>Implementation hint:</u> If you implement fast scan mode by seeking
        every 100 ms forward or reverse, then you need to seek <tt>SkipSpeed</tt>
        * 100 ms every time to get the desired average speed.</p>
    </blockquote>
    <h5><tt>DECODER_STOP</tt></h5>
    <blockquote>
      <p>Stop decoding of the current song. This should terminate the decoder
        thread. After <tt>DECODER_STOP</tt> the decoder should ignore all
        errors and simply terminate.</p>
    </blockquote>
    <h3><a name="status_interface"></a>Status interface</h3>
    <p>The status interface has to be <em>thread safe</em>.</p>
    <h4><a name="decoder_status"></a>decoder_status</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_status</b>(struct DECODER_STRUCT *<var>w</var>)</pre>
    </blockquote>
    <ul>
      <li><i>return value</i> - One of the following:<br>
        <tt>DECODER_STOPPED<br>
          DECODER_PLAYING<br>
          DECODER_STARTING<br>
          DECODER_PAUSED<br>
          DECODER_STOPPING</tt></li>
    </ul>
    <h4><a name="decoder_length"></a>decoder_length</h4>
    <blockquote>
      <pre>PM123_TIME DLLENTRY <b>decoder_length</b>(struct DECODER_STRUCT *w)</pre>
    </blockquote>
    <ul>
      <li><i>return value</i> - number of seconds the stream lasts (you can
        report <code>-1</code> if unknown).</li>
    </ul>
    <p>The call to this function must be valid even if <tt>DECODER_STARTING</tt>
      or <tt>DECODER_STOPPED</tt> is reported (when the stream plays too fast
      for example). The function is used to follow increasing length of files
      that are written on the fly while playing.</p>
    <h3><a name="output_interface"></a>Output interface</h3>
    <p>The decoder must use this interface to pass the decoded samples to the
      output stage. The samples must be passed as <em>32 bit floating point
        values</em>.</p>
    <p>Strictly speaking this is part of the <a href="#playback_interface">playback
        interface</a>, but the interface functions have to be called by the
      decoder in a separate thread.&nbsp;The function entry points for these
      callbacks are passed in <code>DECODER_PARAMS2</code> at the <tt><a href="#decoder_command">DECODER_SETUP</a></tt>
      call.</p>
    <p>The level 3 interface allocates the buffers by the consumer. This causes
      less double buffering and allows dynamic buffer sizes. In the optimal case
      the samples can be placed immediately in the output buffers of the audio
      device.</p>
    <p>You must call <code>OutRequestBuffer</code> and <code>OutCommitBuffer</code>
      alternately to pass the samples to the next plugin. Anything else is an
      error. Note that any of the two functions might block.</p>
    <h4><a name="OutRequestBuffer"></a><b>OutRequestBuffer</b></h4>
    <blockquote>
      <pre>int (DLLENTRYP <b>OutRequestBuffer</b>)(void* <var>a</var>, const <a
href="datatype.html#FORMAT_INFO2">FORMAT_INFO2</a>* <var>format</var>, float** <var>buf</var>)</pre>
    </blockquote>
    <ul>
      <li><tt><var>a</var></tt> - pointer from <code>DECODER_PARAMS2</code>.</li>
      <li><tt><var>format</var></tt> - format of the passed samples. The data at
        <code>*<var>format</var></code> need not to be valid after this call
        returned.</li>
      <li><tt><var>buf</var></tt> [out] - pointer to receive a memory location
        where to store the decoded samples.</li>
      <li><var>return value</var> - the number of samples that fit in the
        returned buffer. A return value of &#8804;&nbsp;0 indicates a permanent error.
        PM123 stops the playback in this case.</li>
    </ul>
    <p>If you get a smaller buffer as you need to pass your data you should call
      <code>OutRequestBuffer</code> and <code>OutCommitBuffer</code> again
      until all your data is consumed. There is no guaranteed minimum size of
      the buffer, but you should not expect to get very small buffers quite
      often.</p>
    <h4><a name="OutCommitBuffer"></a><b>OutCommitBuffer</b></h4>
    <blockquote>
      <pre>void (DLLENTRY* <b>OutCommitBuffer</b>)(void* <var>a</var>, int <var>len</var>, <a
href="datatype.html#PM123_TIME">PM123_TIME</a> <var>posmarker</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>a</var></code> - pointer from <code>DECODER_PARAMS2</code>.</li>
      <li><code><var>len</var></code> - used number of samples placed in the
        buffer.</li>
      <li><code><var>posmarker</var></code> - stream position in seconds of the
        first sample that will be stored in this buffer relative to the
        beginning of the stream.</li>
    </ul>
    <p>The length must not be higher than the the return value from the previous
      <code>OutRequestBuffer</code> call. But it might be less than the
      requested length. This causes no significant performance impact as long as
      you do not always pass very few samples.</p>
    <h4><a name="DecEvent"></a>DecEvent</h4>
    Send decoder event to the PM123 core.<br>
    <blockquote>
      <pre>void (DLLENTRY* <b>DecEvent</b>)(void* <var>a</var>, DECEVENTTYPE <var>event</var>, void* <var>param</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>a</var></code> - pointer from <code>DECODER_PARAMS2</code>.</li>
      <li><code><var>event</var></code> - type of the event to send.</li>
      <li><code><var>param</var></code> - event specific parameter. See below.</li>
    </ul>
    <p>The decoder plugin MUST call the above function on the following
      conditions:</p>
    <ul>
      <li><code><b>DECEVENT_PLAYSTOP</b></code> when the stream has finished
        decoding and the last sample has been passed to <code>output_commit_buffer</code>
        or when the decoder received a <tt>DECODER_STOP</tt> command.</li>
      <li><code><b>DECEVENT_PLAYERROR</b></code> when a playback error occurred
        so that PM123 should know to stop immediately.<br>
        <var><tt>param</tt></var> could optionally point to an error text or
        should be NULL otherwise. </li>
      <li><code><b>DECEVENT_SEEKSTOP</b></code> when a <code>DECODER_JUMPTO</code>
        operation is completed (i.e. when no buffers from before the seek is
        sent to the output plugin anymore). The message must also be sent, when
        playback starts in the middle of a song. </li>
      <li><code><b>DECEVENT_CHANGETECH</b></code> is sent whenever you want
        PM123 to change the display of the current technical information of the
        stream (like samplerate). <var>param</var> must point to a <code>TECH_INFO</code>
        structure.</li>
      <li><code><b>DECEVENT_CHANGEOBJ</b></code> is sent whenever you want PM123
        to change the display of the current object information of the stream
        (like song length). <var>param</var> must point to a <code>OBJ_INFO</code>
        structure. Note that you should not sent the bitrate of individual MPEG
        frames this way like the level 1 interface supported by <tt>WM_CHANGEBR</tt>.
        The object information keeps the bitrate of the entire stream. </li>
      <li><code><b>DECEVENT_METADATA</b></code> is sent whenever streaming
        metadata is updated. <var>param</var> must point to a <code>META_INFO</code>
        structure.</li>
    </ul>
    Once a decoder raised a <tt>DECODER_PLAYSTOP</tt> or <tt>DECODER_ERROR</tt>
    event it shall not use any callback functions until it receives a <tt>DECODER_PLAY</tt>
    command.<br>
    <h4><a name="decoder_event"></a>decoder_event</h4>
    Receive event from the PM123 core.<br>
    <blockquote>
      <pre>void DLLENTRY <b>decoder_event</b>(void* <var>w</var>, OUTEVENTTYPE <var>event</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>w</var></code> - pointer from <code>decoder_init</code></li>
      <li> <var>event</var> - one of the following values<br>
        <code>OUTEVENT_LOW_WATER</code> - the output plugin detected that it
        will run out of data soon.<br>
        <code>OUTEVENT_HIGH_WATER</code> - the output plugin detected a clear
        condition.</li>
    </ul>
    <p>The events may be used to speed up the data source. If you get <code>OUTEVENT_HIGH_WATER</code>
      you should return to normal behavior. There is one task that the core
      engine does for you: <em>PM123 automatically changes the priority of the
        decoder thread</em>. So if there is nothing more the decoder can do
      (e.g. QoS settings) it could safely ignore the events. </p>
    <p>The event handler may be called from any thread in any context. It might
      be called when the decoder is in stopped state if the end of the stream
      has been reached recently. This should be ignored. You will usually get a
      <code>OUTEVENT_LOW_WATER</code> call immediately after the decoding
      started or after a seek command because the buffers are not yet filled.</p>
    <p>The export of <tt>decoder_event</tt> is optional.</p>
    <var></var>
    <h3><a name="save_interface"></a>Save interface</h3>
    <h4><a name="decoder_saveinfo"></a>decoder_saveinfo</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_saveinfo</b>(char* <var>url</var>, const META_INFO* <var>info</var>, int <var>haveinfo</var>, xstring* <var>errortext</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>url</var></code> - URI to the desired object.</li>
      <li><code><var>info</var></code> - new meta information to write.<br>
        Only the fields with the corresponding bits in <tt><var>haveinfo</var></tt>
        set must be modified. The others should be left unchanged. </li>
      <li><code><var>haveinfo</var></code> - Components of info to modify.</li>
      <li><var><tt>errortext</tt></var> - place a descriptive error text here if
        the function fails.<var> </var></li>
      <li><var>return value</var><br>
        <code>PLUGIN_OK</code> (0) = everything is perfect, meta info is saved
        to <code><var>url</var></code>.<br>
        <tt>PLIGIN_ERROR</tt> (<tt>500</tt>) = failed.</li>
    </ul>
    <p>The function modifies the meta information of a certain song. Calling the
      function should succeed even if the file is currently playing.</p>
    <h4><a name="decoder_savefile"></a>decoder_savefile</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_savefile</b>(const char* <var>url</var>, const char* format, int* <var>what</var>, const INFO_BUNDLE* <var>info</var>,<br>                                <a
href="#DECODER_SAVE_ENUMERATION_CB">DECODER_SAVE_ENUMERATION_CB</a> <var>cb</var>, void* <var>param</var><var></var>, xstring* <var>errortext</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>url</var></code> - URI to the desired object.<br>
        It is valid to pass a URI of a currently playing song. The decoder
        should be able to handle that appropriately.</li>
      <li><var><tt>format</tt></var> - optional format parameter if the decoder
        supports different file formats.<br>
        <code><var></var></code></li>
      <li><code><var>what</var></code> (in/out) - Bit vector of <tt><a href="datatype.html#INFOTYPE"><tt>INFOTYPE</tt></a></tt>
        flags with the information to save. Any information that corresponds to
        bits that are not set in <tt>*<var>what</var></tt> should be preserved
        by this call. And if <tt>INFO_META</tt> is specified, any meta
        information that does not have the corresponding bit in <tt>info-&gt;meta-&gt;haveinfo</tt>
        set, should be left unchanged too.<br>
        On return the decoder resets the the bits in <tt>*<var>what</var></tt>
        that could not be saved because they are not supported in the requested
        format.<br>
        Furthermore the decoder may set the <tt>INFO_PHYS</tt> bit to indicate
        that <tt>*<var>info</var>-&gt;phys</tt> has been updated with recent
        informations after the update. (Of course, PM123 will never request this
        on input.) </li>
      <li><var><code>info</code></var> - Information of the playlist object
        itself. Usually playlists do not contain additional object information
        other than their content. So the info may be mostly ignored. However, it
        could speed up PM123 if <code>decoder_fileinfo</code> can restore some
        infos in a cheap way.</li>
      <li><var><code>cb</code></var> - Enumeration callback. The decoder should
        call this function<code></code> to retrieve the information about the
        playlist content from PM123, but only if <tt>*<var>what</var></tt>
        contains <tt>INFO_CHILD</tt>.</li>
      <li><var><code>param</code></var> - Parameter to be passed as first
        argument to <code>*cb</code>.</li>
      <li><var><tt>errortext</tt></var> - place a descriptive error text here if
        the function fails.<var> </var></li>
      <li><var>return value</var><br>
        <code>PLUGIN_OK</code> (<tt>0</tt>) = everything is perfect, meta info
        is saved to <code><var>url</var></code>.<br>
        <tt>PLIGIN_ERROR</tt> (<tt>500</tt>) = failed. </li>
    </ul>
    <p>The function is used to modify a file (or other object) in place. It is
      currently only used to save playlists.</p>
    <h5><a name="DECODER_SAVE_ENUMERATION_CB"></a>DECODER_SAVE_ENUMERATION_CB</h5>
    <blockquote>
      <pre>int (DLLENTRY* <b>cb</b>)(void* <var>param</var>, <a href="xstring.html">xstring</a>* <var>url</var>, const <a
href="datatype.html#INFO_BUNDLE">INFO_BUNDLE</a>** <var>info</var>, int* <var>cached</var>, int* <var>reliable</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>param</var></code> - Arbitrary parameter from&nbsp;<code>decoder_savelist</code>.</li>
      <li><code><var>url</var></code>&nbsp;(out) - Return URI of the sub item.
        The URI may be absolute or relative. In case of relative URIs the
        context of the enclosing playlist is used for URI resolution. <em>Note
          that the <a href="xstring.html"><tt>xstring</tt> structure</a> must
          be initialized</em> when the function is called.</li>
      <li><code><var>info</var></code> (out) - Return known information about
        the sub item. The decoder can store this information in the playlist and
        return it when the list is read with <a href="#decoder_fileinfo"><tt>decoder_fileinfo</tt></a>
        to speed up large playlists.<br>
        The storage where <tt>*info</tt> points to is only valid until the next
        call to <tt>cb</tt> or until <tt>decoder_savefile</tt> returned. </li>
      <li><code><var>cached, reliable</var></code> (out) - Return <a href="datatype.html#INFOTYPE"><code>INFOTYPE</code></a>
        bit vectors. See <a href="#DECODER_INFO_ENUMERATION_CB"><tt>DECODER_INFO_ENUMERATION_CB</tt></a>
        for details.<br>
        The decoder should not store information that is not at least cached.
        When both bits are set the specified type of information in <code>**<var>info</var></code>
        is overridden by this reference only. The decoder should store this
        information together with the URI reference when possible.</li>
      <li><var>return value</var> -&nbsp;<code>PLUGIN_OK</code> (<tt>0</tt>) =
        everything is fine, anything else = error, e.g. no more items.</li>
    </ul>
    This function retrieves the next sub item from the currently saved playlist.
    PM123 will fill all fields according to the above rules.
    <h5><a name="DECODER_FILETYPE"></a>DECODER_FILETYPE</h5>
    <blockquote>
      <pre>typedef struct<br>{ const char* category;<br>  const char* eatype;<br>  const char* extension;<br>  int         flags;<br>} <b>DECODER_FILETYPE</b>;</pre>
    </blockquote>
    <table border="1" cellpadding="3" cellspacing="0">
      <tbody>
        <tr>
          <th>Field</th>
          <th>Meaning</th>
        </tr>
        <tr>
          <td><tt>category</tt></td>
          <td>File type category, e.g. "<tt>Playlist file</tt>"<br>
            This field is only used for reading files.</td>
        </tr>
        <tr>
          <td><tt>eatype</tt></td>
          <td>File type, e.g. "<tt>PM123 playlist file</tt>"</td>
        </tr>
        <tr>
          <td><tt>extension</tt></td>
          <td>File extension, e.g. "<tt>*.lst;*.m3u</tt>"</td>
        </tr>
        <tr>
          <td><tt>flags</tt></td>
          <td>Bit vector of <tt>DECODER_TYPE</tt>.<br>
            <tt> DECODER_FILENAME</tt> (1) - Decoder can play files of this
            type, should always be set for EA types.<br>
            <tt> DECODER_URL</tt> (2) - Decoder can play URIs (http, ftp, etc.),
            should be set for MIME types.<br>
            <tt>DECODER_SONG</tt> (0x0100) - Decoder can play songs with this
            file type.<br>
            <tt>DECODER_PLAYLIST</tt> (0x0200) - Decoder can play playlists with
            this file type.<br>
            <tt>DECODER_WRITABLE</tt> (0x1000) - Decoder can save items of this
            type.<br>
            <tt>DECODER_METAINFO</tt> (0x2000) - Decoder can save a meta info. </td>
        </tr>
      </tbody>
    </table>
    <p><strong>TODO</strong></p>
    <h3><a name="GUI_interface"></a>GUI enhancement interface</h3>
    <p>The following functions are used to improve the GUI of PM123 with plugin
      specific content.<br>
      <em>All functions in this section are optional.</em></p>
    <h4><a name="decoder_editmeta"></a>decoder_editmeta</h4>
    <blockquote>
      <pre>ULONG DLLENTRY <b>decoder_editmeta</b>(HWND <var>owner</var>, const char* <var>url</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>owner</var></code> - Parent window handle.</li>
      <li><code><var>url</var></code> - URL to the desired stream. See <a href="#url_samples">URI
          samples</a>. Keep in mind that this URL may be the same as the one
        currently played. The plugin must handle this concurrent write access.</li>
      <li><var>return value</var> -<br>
        <tt>PLUGIN_OK &nbsp; &nbsp;&nbsp;</tt> (<tt>0</tt>) = everything is
        perfect, information has been changed. PM123 will invalidate the Meta
        information of this URL and likely call <a href="#decoder_fileinfo"><tt>decoder_fileinfo</tt></a>
        to update its internal cache.<br>
        <tt>PLUGIN_NO_READ</tt> (<tt>200</tt>) = decoder can't handle that.
        (PM123 raises an error dialog)<br>
        <tt>PLUGIN_NO_OP &nbsp;</tt> (<tt>300</tt>) = no change, e.g. user
        abort. This return value should also be used when the plugin already
        raised a meaningful message using <tt>plugin_api-&gt;error_display</tt>.<br>
        <tt>PLUGIN_NO_SAVE</tt> (<tt>400</tt>) = can't edit tag of this stream.
        (PM123 raises an error dialog)<br>
        <tt>PLUGIN_ERROR &nbsp;</tt> (<tt>500</tt>) = error writing tag. (PM123
        raises an error dialog) </li>
    </ul>
    <p>If <code>decoder_editmeta</code> is not implemented, the edit tag entry
      is always disabled. </p>
    <h4><a name="decoder_getwizard"></a>decoder_getwizard</h4>
    <blockquote>
      <pre>const DECODER_WIZARD* DLLENTRY <b>decoder_getwizard</b>(void)</pre>
    </blockquote>
    <ul>
      <li><var>return value</var> - Zero or more <code>DECODER_WIZARD</code>
        structures (linked list).<br>
        Each structure represents an entry in the context menu to load something
        into the player or a playlist. To terminate the list of <code>DECODER_WIZARD</code>
        objects set the link pointer to <code>NULL</code>. The returned storage
        must be valid until the next call to <code>decoder_getwizard</code> or
        the plugin gets unloaded.</li>
    </ul>
    <p>If the function is not implemented or returns <code>NULL</code> the
      context menu is not extended with entries specific to this plugin.</p>
    <p>The field <code>prompt</code> is the menu text. It should not contain
      information about the accelerator key, because this is generated
      automatically.</p>
    <p>The fields <code>accel_key</code>[<code>2</code>] and <code>accel_opt</code>[<code>2</code>]
      can be used to extend the accelerator table of PM123. They correspond to
      the fields <code>key</code> and <code>fs</code> of the <code>ACCEL</code>
      structure. The first set of entries is used for the PM123 main window and
      the playlist windows. The second set is for the Playlist Manager to append
      to the currently selected playlist.<br>
      You should set <code>accel_key</code> to <code>0</code> if you do not
      want an accelerator key for your plugin's wizard dialog. Be careful with
      the choice of the accelerator keys because there may be clashes. Using Alt
      for the first entry and Shift-Alt for the second entry as meta keys is
      recommended.</p>
    <p>When the menu entry is selected the corresponding wizard function is
      called by PM123.</p>
    <blockquote>
      <pre>ULONG (DLLENTRY* <b>wizard</b>)(HWND <var>owner</var>, const char* <var>title</var>,<br>                         <a
href="#DECODER_INFO_ENUMERATION_CB">DECODER_INFO_ENUMERATION_CB</a> <var>callback</var>, void* <var>param</var>)</pre>
    </blockquote>
    <ul>
      <li><code><var>owner</var></code> - Parent window handle.</li>
      <li><code><var>title</var></code> - Window title.<br>
        The title may contain <samp>"%s"</samp> for the object type. E.g. <samp>"Add%s
          to playlist."</samp> may evaluate to <samp>"Add track(s) to
          playlist."</samp>.</li>
      <li><code><var>callback</var></code> - Function that will be called for
        each selected item.</li>
      <li><code><var>param</var></code> - Parameter to pass to the callback
        function as the first argument.</li>
      <li><var>return value</var> -<br>
        <tt>PLUGIN_OK &nbsp;&nbsp;</tt> (<tt>0</tt>)<tt> &nbsp;</tt> = OK, <code><var>callback</var></code>
        has been called at least once.<br>
        <tt>PLUGIN_NO_OP</tt> (<tt>300</tt>) = Cancel. Do not add/play anything.<br>
        <tt>PLUGIN_ERROR</tt> (<tt>500</tt>) = Internal error.</li>
    </ul>
  </body>
</html>
