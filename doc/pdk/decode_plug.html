<html>
<head>
   <title>Decoder Plug-ins</title>
</head>
<body>
<h2>PM123 Decoder Plug-ins</h2>
<p>Decoder plug-ins must implement and export the functions defined in <tt>decode_plug.h</tt>.</p>
<p>There are two interface revision levels.
  For developing new plug-ins the revision 2 interface is recommended.
  Before including any PM123 include file the macro <code>DECODER_PLUGIN_LEVEL</code> must be defined
  if you want to use anything higher than level 0. Example:
<pre>     #define DECODE_PLUGIN_LEVEL 2</pre>

<h3>Interface revision level 2 (recommended)</h3>

<h4><a name="initialization_interface"></a>Initialization interface</h4>
<p>
Decoder plug-ins must implement and export the functions defined in
decoder_plug.h.
<blockquote>
<pre>
int  DLLENTRYP <b>decoder_init</b>  ( void **w )
BOOL DLLENTRYP <b>decoder_uninit</b>( void *w  )
</pre>
</blockquote>
<ul>
<li>w : Allocate any chunk of memory necessary for the decoder's
function. This pointer will be passed to the other functions.
<li>return value : PLUGIN_FAILED (-1) means the decoder was not initialized
successfully.
</ul>
<p>
Init function is called when PM123 needs the specified decoder
to play the stream demanded by the user. So only one decoder plug-in is
active at any given time. It should initialize the necessary semaphores
and threads. <code>decoder_uninit</code> is called when another decoder
than yours is needed, and should destroy the decoder's thread,
semaphores, other opened handles and free allocated memory for <i>w</i>.

<h4><a name="control_interface"></a>Control interface</h4>
<blockquote>
<pre>ULONG DLLENTRYP <b>decoder_command</b>( void *w, ULONG msg, DECODER_PARAMS2 *params )</pre>
</blockquote>
<ul>
<li>msg: one of the following:
<ul>
<li>DECODER_PLAY start playing the given filename, URL or others.
<li>DECODER_STOP stop playing.
<li>DECODER_FFWD engage in ffwd mode (ie.: play faster or skip when playing).
<li>DECODER_REW  engage rewind mode.
<li>DECODER_JUMPTO jump and start decoding at the given time position.
<li>DECODER_SETUP setup various parameters such as the output plugin
functions, hwnd where to send messages and an optional play semaphore.
<li>DECODER_EQ usually only useful for MPEG decoding where frequency
equalization is cheap.
<li>DECODER_SAVEDATA tells the decoder to start saving the stream to HD.
</ul>
<li>params: structure that contains the parameters needed by the preceding
commands.
<li>return value:<br>
PLUGIN_OK (0) -> ok.<br>
PLUGIN_UNSUPPORTED (1) -> command unsupported.<br>
DECODER_PLAY and DECODER_STOP can return also PLUGIN_GO_ALREADY (101) and
PLUGIN_GO_FAILED (102).
</ul>
<p>
There is a lot of commands to implement for this function. Parameters
needed for each of the are described in the definition of the structure
in the decoder_plug.h file. The decoder necessarily should support following commands:
DECODER_SETUP, DECODER_PLAY, DECODER_STOP and DECODER_JUMPTO.
<p><a name="url_samples"></a>In the level 2 interface the data source always passed as an URL.
  The URL parameter uses the following syntax:
<blockquote>
  <samp>file:///D:/Music/my favorite song.mp3</samp><br>
  <samp>file://server/share/path/song.mp3 </samp>UNC path<br>
  <samp>http://... </samp>(as you would expect)<br>
  <samp>cdda:///H:/track02</samp>
</blockquote>

<h4><a name="status_interface"></a>Status Interface</h4>
<p>The status interface has to be thread safe.</p> 
<blockquote>
<pre>ULONG DLLENTRYP <b>decoder_status</b>( void *w )</pre>
</blockquote>
<ul>
<li>return value - One of the following:<br>
DECODER_STOPPED<br>
DECODER_PLAYING<br>
DECODER_STARTING<br>
DECODER_PAUSED<br>
</ul>
<blockquote>
<pre>ULONG DLLENTRYP <b>decoder_length</b>( void *w )</pre>
</blockquote>
<ul>
<li>return value - number of milliseconds the stream lasts (you can
report <code>(ULONG)-1</code> if unknown).
</ul>
<p>
The call to this function must be valid even if <i>DECODER_STARTING</i> or
<i>DECODER_STOPPED</i> is reported (when the stream plays too fast for
example).

<h4><a name="info_interface"></a>Info interface</h4>
<p>The info interface functions must be independent of the current decoder status.
They should always be functionnaly and give consistent results in any conditions.
The functions must be <em>thread safe</em>.
</p>
<blockquote>
<pre>ULONG DLLENTRYP <b>decoder_fileinfo</b>( const char *url, DECODER_INFO2 *info )</pre>
</blockquote>
<ul>
<li><var>url</var> - URL to the desired stream. See <a href="#url_samples">URL samples</a>.
<li><var>info</var> - this structure must be filled with the required information.
  See <tt>format.h</tt> for further details.
<li><var>return value</var> -<br>
PLUGIN_OK (0) = everything's perfect, structure is set.<br>
PLUGIN_NO_READ (100) = error reading file (too small?).<br>
PLUGIN_NO_PLAY (200) = decoder can't play that.<br>
1001 = http error occured.<br>
other values = errno.
</ul>
<blockquote>
<pre>ULONG DLLENTRYP <b>decoder_cdinfo</b>( const char *drive, DECODER_CDINFO *info )</pre>
</blockquote>
<ul>
<li>drive: ...
<li><var>info</var> - required info on the number of tracks available from the
decoder.</lI>
</ul>
<p>
This function is unused by PM123 since version 1.40 but it might still be invoked by visual plug-ins.
You need not to export this function unless <code>decoder_support</code> returns the DECODER_TRACK flag. 
<blockquote>
<pre>ULONG DLLENTRYP <b>decoder_support</b>( char *const fileext[], int *size )</pre>
</blockquote>
<ul>
<li><var>fileext</var> - fill this array with all the wildcard expression matching
filenames this decoder can play (each element is a 8 bytes char array).
<li><var>size</var> - number of wildcard expressions returned (if this value is not
big enough, ie.: 0, return the appropriate size without filling
fileext).
<li><var>return value</var> - return what kind of stream can the decoder play:<br>
DECODER_FILENAME<br>
DECODER_URL<br>
DECODER_TRACK<br>
DECODER_OTHER<br>
The values may be ored.
</ul>
<p>
This is used by PM123 to suggest to the user what he can play with the
decoder. Extentions can be for example "*.MOD".

<h4><a name="GUI_interface"></a>GUI enhancement interface</h4>
<p>The following functions are used to improove the GUI of PM123 with plug-in specific content.<br>
<em>All functions in this section are optional.</em>
<blockquote>
<pre>ULONG DLLENTRYP <b>decoder_editmeta</b>( HWND owner, const char* url )</pre>
</blockquote>
<ul>
<li><var>owner</var> - Parent window handle.
<li><var>url</var> - URL to the desired stream. See <a href="#url_samples">URL samples</a>.
  Keep in mind that this URL may be the same as the one currently played.
  The plug-in must handle this concurrent write access.
<li><var>return value</var> -<br>
0 = everything's perfect, information has been changed.<br>
200 = decoder can't handle that. (PM123 raises the error dialog)<br>
300 = no change, e.g. user abort.<br>
400 = can't edit tag of this stream. (PM123 raises the error dialog)<br>
500 = error writing tag. (PM123 raises the error dialog)
</ul>
<p>If <code>decoder_editmeta</code> is not implemented, the edit tag entry is disabled.
<blockquote>
<pre>const DECODER_WIZZARD* DLLENTRYP <b>decoder_getwizzard</b>( )</pre>
</blockquote>
<ul>
<li><var>return value</var> - Zero or more <code>DECODER_WIZZARD</code> structures (linked list).<br>
  Each structure represents an entry in the context menu to load something into the player or a playlist.
  To terminate the list of <code>DECODER_WIZZARD</code> objects set the link pointer to <code>NULL</code>.
  The returned storage must be valid until the next call to <code>decoder_getwizzard</code> or the plug-in gets unloaded.
</ul>
<p>If the function is not implemented or returns <code>NULL</code>
  the context menu is not extended with entries specific to this plug-in.
<p>The field <code>prompt</code> is the menu text. It should not contain information about the accelerator key,
  because this is generated automatically.
<p>The fields <code>accel_key</code>[<code>2</code>] and <code>accel_opt</code>[<code>2</code>] can be used to extend the accelerator table of PM123.
  They correspond to the fields <code>key</code> and <code>fs</code> of the <code>ACCEL</code> structure.
  The first set of entries is used for the PM123 main window and the playlist windows.
  The second set is for the Playlist Manager to append to the currently selected playlist.<br>
  You should set <code>accel_key</code> to <code>0</code> if you do not want an accelerator key
  for your plug-in's wizzard dialog.
  Be careful with the choice of the accelerator keys because there may be clashes.
  Using Alt and Shift-Alt as meta keys is recommended.
<p>When the menu entry is selected the corresponding wizzard function is called by PM123.
<blockquote>
<pre>ULONG (DLLENTRYP <b>wizzard</b>)( HWND owner, const char* title,
                           void (DLLENTRYP callback)( void* param, const char* url ), void* param );</pre>
</blockquote>
<ul>
<li><var>owner</var> - Parent window handle.
<li><var>title</var> - Window title.<br>
  The title may contain <samp>"%s"</samp> for the object type.
  E.g. <samp>"Add%s to playlist."</samp> may evaluate to <samp>"Add track(s) to playlist."</samp>.
<li><var>callback</var> - Function that will be called for each selected item.
<li><var>param</var> - Parameter to pass to the callback function as the first argument.
<li><var>return value</var> -<br>
  0 = OK, <var>callback</var> has been called at least once.<br>
  300 = Cancel. Do not add/play anything.<br>
  500 = Internal error.
</ul>

<h4><a name="output_interface"></a>Output interface</h4>
<p>The decoder must use this interface to pass the decoded samples to the output stage.
  The samples must be passed as 16 bit signed integers.</p> 
<p>The function entry points for these callbacks are passed in <code>DECODER_PARAMS2</code>
  at the <a href="#control_interface">DECODER_SETUP</a> call.<br>
  The interface functions have to be called by the decoder in a separate thread.</p>
<p>The level 2 interface allocates the buffers by the consumer.
  This causes less double buffering and allows dynamic buffer sizes.</p>
<p>You must call <code>output_request_buffer</code> and <code>output_commit_buffer</code>
  alternatingly to pass the samples to the next plug-in. Anything else is an error.</p>

<blockquote>
<pre>int (DLLENTRYPP <b>output_request_buffer</b>)( void* a, const FORMAT_INFO2* format, short** buf )</pre>
</blockquote>
<ul>
  <li><var>a</var> - pointer from <code>DECODER_PARAMS2</code>.
  <li><var>format</var> - format of the passed samples.<br>
    See <code>FORMAT_INFO2</code> in <tt>format.h</tt> for more details.
    The data at <code>*format</code> need not to be valid after this call returned.
  <li><var>buf</var> [out] - pointer to receive a memory location where to store the decoded samples.<br>
  <li><var>return value</var> - the number of samples that fit in the returned buffer.
    A return value of &le;&nbsp;0 indicates a permanent error.
</ul>
<p>If you get a smaller buffer as you need to pass your data you should call <code>output_request_buffer</code> and <code>output_commit_buffer</code> again untill all your data is consumed.
  There is no guaranteed minimum size of the buffer. You should not expect this to get very small buffers quite often.</p>
<blockquote>
<pre>void (DLLENTRYPP <b>output_commit_buffer</b>)( void* a, int len, int posmarker )</pre>
</blockquote>
<ul>
  <li><var>a</var> - pointer from <code>DECODER_PARAMS2</code>.
  <li><var>len</var> - used number of samples placed in the buffer.
  <li><var>posmarker</var> - stream position in milliseconds of the first sample that will be stored in this buffer relative to the beginning of the stream.
</ul>
<p>The length must not be higher than the the return value from the previous <code>output_request_buffer</code> call.
  But it might be less than the requested length.
  This causes no significant performance impact as long as you do not always pass very few samples.</p>
<blockquote>
<pre>void (DLLENTRYPP <b>output_event</b>)( void* a, DECEVENTTYPE event, void* param )</pre>
</blockquote>
<ul>
  <li><var>a</var> - pointer from <code>DECODER_PARAMS2</code>.
  <li><var>event</var> - type of the event to send.
  <li><var>param</var> - event specific parameter. See below.
</ul>
<p>
The decoder plug-in MUST call the above function on the following conditions:
<ul>
<li><code><b>DECEVENT_PLAYSTOP</b></code> when the stream has finished decoding and the last sample has been passed to <code>output_commit_buffer</code>.
<li><code><b>DECEVENT_PLAYERROR</b></code> when a playback error occured so that PM123 should know to stop immediately.
<li><code><b>DECEVENT_SEEKSTOP</b></code> when a <code>DECODER_JUMPTO</code> operation is completed (ie.: when no buffers from before the seek is sent to the output plugin anymore).
<li><code><b>DECEVENT_CHANGTECH</b></code> is sent whenever you want PM123 to change the display of the current technical information of stream (like bitrate).
   <var>param</var> must point to a <code>TECH_INFO</code> structure.
<li><code><b>DECEVENT_METADATA</b></code> is sent whenever streaming metadata is updated. 
   <var>param</var> must point to a <code>META_INFO</code> structure.
</ul>

<blockquote>
<pre>void DLLENTRYP <b>decoder_event</b>( void* w, OUTEVENTTYPE event );</pre>
</blockquote>
<ul>
  <li><var>w</var> - pointer from <code>decoder_init</code>
  <li><var>event</var> - one of the following values<br>
    <code>OUTEVENT_LOW_WATER</code> - the ouput plug-in detected that it will run out of data soon.<br>
    <code>OUTEVENT_HIGH_WATER</code> - the ouput plug-in detected a clear condition.
</ul>
<p>The events may be used to speed up the data source e.g. by manipulating the decoder thread's priority.
  If you get <code>OUTEVENT_HIGH_WATER</code> you sholud return to normal behaviour.</p>
<p>The event handler may be called from any thread in any context.
  It might be called when the decoder is in stopped state if the end of the stream has been reached recently.
  This should be ignored.</p>
<p>You will usually get a <code>OUTEVENT_LOW_WATER</code> call immiediately after the decoding started
  or after a seek command because the buffers are not yet filled.</p>


<h3><a name="level_1"></a>Interface revision level 0 and 1</h3>

<h4>Initialization interface</h4>
<p>See <a href="#initialization_interface">level 2 initialization interface</a>.
  This part of the interface has not been changed.</p>

<h4><a name="control_interface1"></a>Control interface</h4>
<blockquote>
<pre>ULONG DLLENTRYP decoder_command( void *w, ULONG msg, DECODER_PARAMS *params )</pre>
</blockquote>
<ul>
<li>msg: one of the following:
<ul>
<li>DECODER_PLAY start playing the given filename, URL or others.
<li>DECODER_STOP stop playing.
<li>DECODER_FFWD engage in ffwd mode (ie.: play faster or skip when playing).
<li>DECODER_REW  engage rewind mode.
<li>DECODER_JUMPTO jump and start decoding at the given time position.
<li>DECODER_SETUP setup various parameters such as the output plugin
functions, hwnd where to send messages and an optional play semaphore.
<li>DECODER_EQ usually only useful for MPEG decoding where frequency
equalization is cheap.
<li>DECODER_BUFFER reports the reader buffer status.
<li>DECODER_SAVEDATA tells the decoder to start saving the stream to HD.
</ul>
<li>params: structure that contains the parameters needed by the preceding
commands.
<li>return value:<br>
PLUGIN_OK (0) -> ok.<br>
PLUGIN_UNSUPPORTED (1) -> command unsupported.<br>
DECODER_PLAY and DECODER_STOP can return also PLUGIN_GO_ALREADY (101) and
PLUGIN_GO_FAILED (102).
</ul>
<p>
There is a lot of commands to implement for this function. Parameters
needed for each of the are described in the definition of the structure
in the decoder_plug.h file. The decoder necessarily should support following commands:
DECODER_SETUP, DECODER_PLAY, DECODER_STOP and DECODER_JUMPTO.
<p>
The decoder plug-in MUST <i>WinPostMsg()</i> the following messages to <i>hwnd</i>:
<ul>
<li>WM_PLAYSTOP when the stream has finished decoding.
<li>WM_PLAYERROR when a playback error occured so that PM123 should know to
stop immediately.
<li>WM_SEEKSTOP when a JUMPTO operation is completed (ie.: when no buffers
from before the seek is sent to the output plugin anymore).
<li>WM_CHANGEBR is sent whenever you want PM123 to change the display
of the current bitrate. mp1 = current bitrate in kbit/s.
<li>WM_METADATA is sent whenever streaming metadata is updated and
contains the pointer to the streaming metadata in mp1. This pointer
should be the same one that is passed with DECODER_SETUP because it is
garanteed to be available to PM123 without memory leaking.
</ul>
<p>
Streaming metadata currently is for SHOUTcast (and icecast is using the same
method), so it is a string with the following format:
<blockquote>
<pre>StreamingTitle='blah blah';StreamingURL='more useless information';</pre>
</blockquote>
Only StreamingTitle is used by PM123.

<h4>Status Interface</h4>
<p>See <a href="#status_interface">level 2 status interface</a>.
  This part of the interface has not been changed.</p>

<h4><a name="info_interface1"></a>Info interface</h4>
<p>The info interface functions must be independent of the current decoder status.
They should always be functionnaly and give consistent results in any conditions.
The functions must be <em>thread-safe</em>.
</p>
<blockquote>
<pre>ULONG DLLENTRYP <b>decoder_fileinfo</b>( const char *url, DECODER_INFO *info )</pre>
</blockquote>
<ul>
<li><var>url</var> - full path or URL to the desired stream.
<li><var>info</var> - this structure must be filled with the required information.
<li><var>return value</var> -<br>
0 = everything's perfect, structure is set.<br>
100 = error reading file (too small?).<br>
200 = decoder can't play that.<br>
1001 = http error occured.<br>
other values = errno.
</ul>
<blockquote>
<pre>ULONG DLLENTRYP <b>decoder_trackinfo</b>( const char *drive, int track, DECODER_INFO *info )</pre>
</blockquote>
<ul>
<li><var>drive</var> - ie.: "X:"
<li><var>track</var> - CD tracks start from 1.
<li><var>info</var> - this structure must be filled with the required information.
<li><var>return value</var> -<br>
PLUGIN_OK (0) = everything's perfect, structure is set.<br>
PLUGIN_NO_READ (100) = error reading file (too small?).<br>
PLUGIN_NO_PLAY (200) = decoder can't play that.<br>
other values = errno.
</ul>
<blockquote>
<pre>ULONG DLLENTRYP <b>decoder_cdinfo</b>( char *drive, DECODER_CDINFO *info )</pre>
</blockquote>
<ul>
<li>drive: ...
<li><var>info</var> - required info on the number of tracks available from the decoder.</lI>
<li>return value:<br>
PLUGIN_OK (0) = everything's perfect, structure is set.<br>
PLUGIN_NO_READ (100) = error reading required info.<br>
other values = errno.
</ul>
<p>
This function is unused by PM123 since version 1.40 but it might still be invoked by visual plug-ins.
You need not to export the CD related functions unless <code>decoder_support</code> returns the DECODER_TRACK flag. 
<blockquote>
<pre>ULONG DLLENTRYP decoder_support( char *fileext[], int *size )</pre>
</blockquote>
<ul>
<li><var>fileext</var> - fill this array with all the wildcard expression matching
filenames this decoder can play (each element is a 8 bytes char array).
<li><var>size</var> - number of wildcard expressions returned (if this value is not
big enough, ie.: 0, return the appropriate size without filling
fileext).
<li><var>return value</var> - return what kind of stream can the decoder play:<br>
DECODER_FILENAME<br>
DECODER_URL<br>
DECODER_TRACK<br>
DECODER_OTHER<br>
The values may be ored.
</ul>
<p>
This is used by PM123 to suggest to the user what he can play with the
decoder and what features are supported. Extentions can be for example "*.MOD".

<h4>GUI enhancement interface</h4>
<p>See <a href="#GUI_interface">level 2 GUI enhancement interface</a>.
  This part of the interface is new with PM123 1.40,
  but since all of the functions are optional it is compatible anyway.</p>

<h4><a name="output_interface1"></a>Output interface</h4>
<p>The decoder must use this interface to pass the decoded samples to the output stage.
 The function entry points for these callbacks are passed in <code>DECODER_PARAMS</code>
 at the <a href="#control_interface1">DECODER_SETUP</a> call.<br>
 The interface functions have to be called by the decoder in a separate thread.</p>

<blockquote>
<pre>int (DLLENTRYPP <b>output_play_samples</b>)( void* a, const FORMAT_INFO* format, const char* buf, int len, int posmarker )</pre>
</blockquote>
<ul>
  <li><var>a</var> - pointer from <code>DECODER_PARAMS</code>.
  <li><var>format</var> - format of the passed samples.<br>
    See <code>FORMAT_INFO</code> in <tt>format.h</tt> for more details.
    The data at <code>*format</code> need not to be valid after this call returned.
  <li><var>buf</var> - data buffer.
  <li><var>len</var> - length of the buffer in bytes.<br>
    Whatever happens the decoder must not pass incomplete samples.
  <li><var>return value</var> - number of samples processed. Anything &ne;&nbsp;<var>len</var> is an error.
</ul>
<p>The decoder should pass the decoded samples to this function.
  The decoder shold pass a bunch of samples at once unless the end of the data is reached
  to keep the performance reasonable.</p>

</body>
</html>


