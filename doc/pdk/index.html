<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>PM123 Plug-in Developer's Guide</title></head>
<body>
<h2>Developing PM123 Plug-ins</h2>
<p>PM123 supports four kinds of plug-ins: visual, decoder,
output and filter. Visual plug-ins are used to peek at the data
currently being heard (or not) by the user through the output plug-in
and visually produce data from it back to the user. Decoder plug-ins
are used to decode different types of files, tracks or streams the user
can play. Output plug-ins is the final destination of the decoded data.
It can be rerouted to a sound card, to the hard disk or anywhere else
appropriate. The data is in standard PCM format. Filter plug-ins are
chained between the decoder and the output plug-in to modify the PCM
data before getting to the output plug-in.</p>
<p>Visual plug-in interface has not been changed since version
1.0,
eventhough they could be ameliorated in the future. Currently, Visual
plug-ins allow the creation of internal or external windows and they
can
tap into PM123 in several ways: they can retrieve currently playing
samples, control PM123 and so on. Plug-ins are Dynamic Linked
Libraries,
DLLs, which PM123 loads on use.</p>
<p>Note that visual plug-ins cannot be
loaded via PM123's Properties dialog because they are skin specific.
They can of course be loaded when loading a new skin.</p>
<h3>Common interface</h3><i>plugin.h</i> contains the necessary structures
for all pm123 plug-ins.
All exported and callback functions must use the calling convention <code>_cdecl</code>.

<h4>Initialization</h4>
<p>A plug-in must have a function that identifies it as a plug-in:
</p>
<blockquote>
<pre>int DLLENTRY <b>plugin_query</b>( PPLUGIN_QUERYPARAM <var>param</var>, const PLUGIN_CONTEXT* <var>ctx</var> );<br></pre>
</blockquote>
<tt>plugin_query</tt> is called before any other function
and exactly once by PM123. The plug-in will then have to fill the
variables in the <i>param</i> structure, for example:
<blockquote>
<pre>param-&gt;type = PLUGIN_VISUAL;<br>/* Identify the plug-in as visual plug-in. Types can be ORred to<br>include multiple plug-in types in the same DLL. */<br><br>param-&gt;author = "Matti Meik&auml;l&auml;inen";<br>/* Author of the plug-in */<br><br>param-&gt;desc = "Example plug-in";<br>/* A short description of the plug-in */<br><br>param-&gt;configurable = TRUE;<br>/* Toggles plug-in configurability via PM123 Properties dialog */<br><br>param-&gt;interface = 2;<br>/* This is the required <a href="#interface_level">interface revision level</a>.<br> * This parameter defaults to 0 which is the same as before this field existed.<br> * Plug-ins with Level 0 <em>must not</em> fill this field to be compatible with older<br> * versions of PM123.<br> */<br><br>return 0;</pre>
</blockquote>
<p>The second parameter <tt><var>ctx</var></tt>
is optional. It provides some global entry points of PM123. They might
be used to handle asynchronous events or requests. The structue and the functions must
not be used after <tt>plugin_deninit</tt> returned.</p>
<blockquote>
<pre>/* Error message function. */<br>void DLLENTRY (*<b>error_display</b>)( const char* <var>msg</var> );<br><br>/* Info message function */<br>/* This information is always displayed to the user right away. */<br>void DLLENTRY (*<b>info_display</b>)( const char* <var>msg</var> );<br><br>/* Execute remote command */<br>/* See the documentation of remote commands for a description. */<br>const char* DLLENTRY (*<b>exec_command</b>)( const char* <var>cmd</var> );<br><br>/* retrieve configuration setting */<br>int DLLENTRY (*<b>query_profile</b>)( const char* <var>key</var>, void* <var>buffer</var>, int <var>maxlength</var> );<br><br>/* store configuration setting */<br>int DLLENTRY (*<b>write_profile</b>)( const char* <var>key</var>, const void* <var>buffer</var>, int <var>length</var> );</pre>
</blockquote>
<p>The <b><tt>exec_command</tt></b> function causes
PM123 to execute a remote command as if it were sent to the remote pipe
interface. It returns the reply string. The returned storage is valid until the next call to <tt>exec_command</tt> or until <tt>plugin_deinit</tt>. &nbsp;Calls to <tt>exec_command</tt> must be serialized.<br>The remote state information
like the currently selected playlist is private to the plug-in and does
not interfere with commands sent to the remote pipe or from other
plug-ins.</p>
<p><b><tt>query_profile</tt></b> and <b><tt>write_profile</tt></b> are similar to the profile OS/2 API functions <tt>PrfQueryProfileData</tt> and <tt>PrfWriteProfileData</tt>.
But they read and write to a section dedicated to your plug-in the
current PM123.INI file which may not be the one in the application
folder. Using this functions is recommended over creating an individual profile.<br> <tt>query_profile</tt> returns the length of the requested Parameter or -1 on error. Independent of the returned length at most <var><tt>maxlen</tt></var> characters are stored in <var><tt>buffer</tt></var>. If you pass <tt>NULL</tt> as <var><tt>key</tt></var>, a list of <tt>'\0'</tt> delimited keys is returned.&nbsp;<tt>write_profile</tt> returns <tt>TRUE</tt> on success and <tt>FALSE</tt> on error.</p>
<h4>Configuration</h4>
<p>If you set <tt>param-&gt;configurable = TRUE</tt>,
a configuration dialog
should appear when PM123 calls
</p>
<blockquote>
<pre>void DLLENTRY <b>plugin_configure</b>( HWND <var>hwnd</var>, HMODULE <var>module</var> );</pre>
</blockquote>
<p>where <i>hwnd</i> is the notebook or player
window so that you can "lock" your
window on it if you want and where <i>module</i> can be
used to load a resource from your DLL.</p>
<h4>Unload</h4>
<p>Plug-ins should deinitialize and destroy their windows and
free allocated
memory when receiving a</p>
<blockquote>
<pre>int DLLENTRY <b>plugin_deinit</b>( int <var>unload</var> );</pre>
</blockquote>
<p>It can also be used to save settings in your INI file for
other sort of plug-ins.</p>
<h3>Plugin types</h3>
<p>Now, which type of plug-in to you want to program?</p>
<ul>
<li><a href="visual_plug.html">Visual Plug-ins</a></li>
<li><a href="decode_plug.html">Decoder Plug-ins</a></li>
<li><a href="output_plug.html">Output Plug-ins</a></li>
<li><a href="filter_plug.html">Filter Plug-ins</a></li>
</ul>
<h3><a name="interface_level"></a>Interface
levels</h3>
<p>The interface level is used to ensure compatibility of
plug-ins over different versions of PM123. The field defaults to 0
representing the oldest implementation. Larger values reflect changes
to the plug-in interface. The interface level reflects changes to any
of the plugin interfaces, so different levels do not neccessarily mean
different interfaces of <em>one</em> plug-in interface. A
change in the interface may be only a modified semantic of a function
call or it may be a complete change of the interface with entirely
other function names or whatever. See the individual PDK documentation
of the desired plug-in type to get further information for each plug-in
type.<br>
A new plugin is not necessarily required to use the most recent
interface level.</p>
<ul>
<li>PM123 will refuse to load plug-ins with a higher interface
level than the one PM123 was compiled with.</li>
<li>PM123 will handle older plug-ins in a compatibility mode as
far as possible.</li>
</ul>
<p>Overview:
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Interface-Level</th>
<th>PM123 version</th>
<th>Visual</th>
<th>Filter</th>
<th>Decoder</th>
<th>Output</th>
</tr>
<tr>
<td>0</td>
<td>n/a</td>
<td><em>no longer supported!</em></td>
<td>supported</td>
<td>supported</td>
<td>supported but deprecated</td>
</tr>
<tr>
<td>1</td>
<td>&ge; 1.32 <font size="-1"><sup><a href="#note1">1</a></sup></font></td>
<td>recent</td>
<td>supported,<br>
same as level 0</td>
<td>supported,<br>
same as level 0</td>
<td>supported but deprecated,<br>
same as level 0</td>
</tr>
<tr>
<td>2</td>
<td>&ge; 1.4</td>
<td>recent,<br>
same as level 1</td>
<td>recent redesign</td>
<td>recent redesign</td>
<td>recent redesign</td>
</tr>
</tbody>
</table>
</p>
<ol>
<li><a name="note1"></a>PM123 version 1.32
does not check for the compatibility of plug-ins. When a wrong plug-in
is used, the application will most likely crash.</li>
</ol>
<p>For example a filter plug-in will be loaded depending on it's
interface level by a PM123 instance with interface level 2 (compile
time constant) in the following way:
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Interface level</th>
<th>Action taken</th>
</tr>
<tr>
<td>2</td>
<td>Loaded native</td>
</tr>
<tr>
<td>1</td>
<td>Loaded via a proxy in compatibility mode.</td>
</tr>
<tr>
<td>0</td>
<td>Loaded via a proxy in compatibility mode.<br>
Level 0 is identical to level 1 with respect to the filter plug-in
interface.</td>
</tr>
<tr>
<td>&gt;2</td>
<td>Error, because the interface is potentially
incompatible and not supported by this PM123 core.<br>
</td>
</tr>
</tbody>
</table>
</p>
</body></html>