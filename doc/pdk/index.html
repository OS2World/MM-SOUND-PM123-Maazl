<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>PM123 Plug-in Developer's Guide</title>
<link rel="stylesheet" href="../common/infstyle.css" type="text/css"></head><body>
<h2>Developing PM123 Plug-ins</h2>
<p>PM123 supports four kinds of plug-ins: visual, decoder,
output and filter. Visual plug-ins are used to peek at the data
currently being heard (or not) by the user through the output plug-in
and visually produce data from it back to the user. Decoder plug-ins
are used to decode different types of files, tracks or streams the user
can play. Output plug-ins is the final destination of the decoded data.
It can be rerouted to a sound card, to the hard disk or anywhere else
appropriate. The data is in standard PCM format. Filter plug-ins are
chained between the decoder and the output plug-in to modify the PCM
data before getting to the output plug-in.</p>
<p>Visual plug-in interface has not been changed since version
1.0,
eventhough they could be ameliorated in the future. Currently, Visual
plug-ins allow the creation of internal or external windows and they
can
tap into PM123 in several ways: they can retrieve currently playing
samples, control PM123 and so on. Plug-ins are Dynamic Linked
Libraries,
DLLs, which PM123 loads on use.</p>
<p>Note that visual plug-ins cannot be
loaded via PM123's Properties dialog because they are skin specific.
They can of course be loaded when loading a new skin.</p>
<h3>Common interface</h3>
<tt>plugin.h</tt> contains the necessary structures
for all PM123 plug-ins.
All exported and callback functions must use the calling convention <code>_cdecl</code>.
<h4>Initialization</h4>
<p><a name="plugin_query"></a>A plug-in must have a function that identifies it as a
plug-in:
</p>
<blockquote>
<pre>int DLLENTRY <b>plugin_query</b>(PPLUGIN_QUERYPARAM <var>param</var>);<br></pre>
</blockquote>
<tt>plugin_query</tt> is called before any other function
and exactly once by PM123. The plug-in will then have to fill the
variables in the <i>param</i> structure, for example:
<blockquote>
<pre>param-&gt;type = PLUGIN_VISUAL;<br>/* Identify the plug-in as visual plug-in. Types can be ORred to<br>include multiple plug-in types in the same DLL. */<br>param-&gt;author = "Matti Meikäläinen";<br>/* Author of the plug-in */<br>param-&gt;desc = "Example plug-in";<br>/* A short description of the plug-in */<br>param-&gt;configurable = TRUE;<br>/* Toggles plug-in configurability via PM123 Properties dialog */<br>param-&gt;interface = 2;<br>/* This is the required <a href="#interface_level">interface revision level</a>.<br> * This parameter defaults to 0 which is the same as before this field existed.<br> * Plug-ins with Level 0 <em>must not</em> access this field to be compatible with older<br> * versions of PM123. */<br>return 0;</pre>
</blockquote>
<p><a name="plugin_init"></a>A second initialization function, <tt>plugin_init</tt>,
is called by the plug-in manager once per plug-in after <tt>plugin_query</tt>.</p>
<blockquote>
<pre>int DLLENTRY <b>plugin_init</b>(const PLUGIN_CONTEXT* <var>ctx</var>);</pre>
</blockquote>
<p>The export of this function is optional but level 2 plug-ins most likely will require it. It provides some
global entry points of PM123. They might
be used to handle asynchronous events or requests. The structure and
the functions must
not be used after <a href="#plugin_deinit"><tt>plugin_deninit</tt></a> returned.</p>
<blockquote>
<pre>/* Error message function. */<br>void DLLENTRY (*<b>error_display</b>)( const char* <var>msg</var> );<br>/* Info message function */<br>/* This information is always displayed to the user right away. */<br>void DLLENTRY (*<b>info_display</b>)( const char* <var>msg</var> );<br><br>/* Execute remote command */<br>/* See the documentation of remote commands for a description. */<br>const char* DLLENTRY (*<b>exec_command</b>)( const char* <var>cmd</var> );<br><br>/* retrieve configuration setting */<br>int DLLENTRY (*<b>query_profile</b>)( const char* <var>key</var>, void* <var>buffer</var>, int <var>maxlength</var> );<br>/* store configuration setting */<br>int DLLENTRY (*<b>write_profile</b>)( const char* <var>key</var>, const void* <var>buffer</var>, int <var>length</var> );<br><br>/* Allocate dynamic string. Any previous content is discarded first.<br> * The returned memory can be written up to len bytes until the next<br> * dstring_* function call on dst. The return value is the same than<br> * dst-&gt;cstr except for constness. */<br>char* DLLENTRY (*<b>dstring_alloc</b>)( DSTRING* dst, unsigned int len );<br>/* Deallocate dynamic string. This will change the pointer to NULL. */<br>void DLLENTRY (*<b>dstring_free</b>)( volatile DSTRING* dst );<br>/* Return the length of a dynamic string */<br>unsigned DLLENTRY (*<b>dstring_length</b>)( const DSTRING* src );<br>/* Compare two DSTRINGs for (binary!) equality. NULL allowed. */<br>int DLLENTRY (*<b>dstring_equal</b>)( const DSTRING* src1, const DSTRING* src2 );<br>/* Reassing dynamic string from C string. Any previous content is discarded first. */<br>void DLLENTRY (*<b>dstring_assign</b>)( volatile DSTRING* dst, const char* cstr );<br>/* Copy dynamic string to another one. Any previous content is discarded first.<br> * This function will not copy the string itself. It only creates an additional reference to the content. */<br>void DLLENTRY (*<b>dstring_copy</b>)( volatile DSTRING* dst, const DSTRING* src );<br>/* Strongly thread safe version of dstring_copy. */<br>void DLLENTRY (*<b>dstring_copy_safe</b>)( volatile DSTRING* dst, volatile const DSTRING* src );<br>/* Append to DSTRING. The source may also be from a DSTRING.<br> * If dst is NULL a new string is created */ <br>void DLLENTRY (*<b>dstring_append</b>)( DSTRING* dst, const char* cstr ); <br>/* printf into a DSTRING. Any previous content is discarded first. */<br>void DLLENTRY (*<b>dstring_sprintf</b>)( volatile DSTRING* dst, const char* fmt, ... );<br>void DLLENTRY (*<b>dstring_vsprintf</b>)( volatile DSTRING* dst, const char* fmt, va_list va );<br></pre>
</blockquote>
<p>The <b><tt>exec_command</tt></b>
function causes
PM123 to execute a remote command as if it were sent to the remote pipe
interface. It returns the reply string. The returned storage is valid
until the next call to <tt>exec_command</tt> or until <tt>plugin_deinit</tt>.
&nbsp;Calls to <tt>exec_command</tt> must be
serialized.<br>
The remote state information
like the currently selected playlist is private to the plug-in and does
not interfere with commands sent to the remote pipe or from other
plug-ins.</p>
<p><b><tt>query_profile</tt></b> and <b><tt>write_profile</tt></b>
are similar to the profile OS/2 API functions <tt>PrfQueryProfileData</tt>
and <tt>PrfWriteProfileData</tt>.
But they read and write to a section dedicated to your plug-in the
current PM123.INI file which may not be the one in the application
folder. Using this functions is recommended over creating an individual
profile.<br>
<tt>query_profile</tt> returns the length of the requested
Parameter or -1 on error. Independent of the returned length at most <var><tt>maxlen</tt></var>
characters are stored in <var><tt>buffer</tt></var>.
If you pass <tt>NULL</tt> as <var><tt>key</tt></var>,
a list of <tt>'\0'</tt> delimited keys is
returned.&nbsp;<tt>write_profile</tt> returns <tt>TRUE</tt>
on success and <tt>FALSE</tt> on error.</p><p>The <a href="dstring.html"><b><tt>dstring_</tt>*</b> API functions</a> are used to manipulate dynamic strings of type <b><tt>DSTRING</tt></b>.</p>
<h4>Configuration</h4>
<p><a name="plugin_configure"></a>If you set <tt>param-&gt;configurable = TRUE</tt>
in <tt>plugin_query</tt>,
a configuration dialog
should appear when PM123 calls
</p>
<blockquote>
<pre>void DLLENTRY <b>plugin_configure</b>(HWND <var>hwnd</var>, HMODULE <var>module</var>);</pre>
</blockquote>
<p>where <i>hwnd</i> is the notebook or player
window so that you can "lock" your
window on it if you want and where <i>module</i> can be
used to load a resource from your DLL.</p>
<h4>Unload</h4>
<p><a name="plugin_deinit"></a>Plug-ins should deinitialize and destroy their windows and
free allocated
memory when receiving a</p>
<blockquote>
<pre>int DLLENTRY <b>plugin_deinit</b>(int <var>unload</var>);</pre>
</blockquote>
<p>It can also be used to save settings in your INI file for
other sort of plug-ins.</p>
<h3>Plugin types</h3>
<p>Now, which type of plug-in to you want to program?</p>
<ul>

<li><a href="source_plug.html">Visual Plug-ins</a></li><li><a href="decoder_plug.html">Decoder Plug-ins</a></li>
<li><a href="output_plug.html">Output Plug-ins</a></li>
<li><a href="filter_plug.html">Filter Plug-ins</a></li>
</ul>
<h3><a name="interface_level"></a>Interface
levels</h3>
<p>The interface level is used to ensure compatibility of
plug-ins over different versions of PM123. The field defaults to 0
representing the oldest implementation. Larger values reflect changes
to the plug-in interface. The interface level reflects changes to any
of the plugin interfaces, so different levels do not neccessarily mean
different interfaces of <em>one</em> plug-in interface. A
change in the interface may be only a modified semantic of a function
call or it may be a complete change of the interface with entirely
other function names or whatever. See the individual PDK documentation
of the desired plug-in type to get further information for each plug-in
type.<br>
A new plugin is not necessarily required to use the most recent
interface level.</p>
<ul>
<li>PM123 will refuse to load plug-ins with a higher interface
level than the one PM123 was compiled with.</li>
<li>PM123 will handle older plug-ins in a compatibility mode as
far as possible.</li>
</ul>
<p>Overview:
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Interface-Level</th>
<th>PM123 version</th>
<th>Visual</th>

<th>Decoder</th>
<th>Output</th><th>Filter</th>
</tr>
<tr>
<td>0</td>
<td>n/a</td>
<td><em>no longer supported!</em></td>

<td>supported</td>
<td>supported but deprecated</td><td>supported</td>
</tr>
<tr>
<td>1</td>
<td>&#8805; 1.32 <font size="-1"><sup><a href="#note1">1</a></sup></font></td>
<td>recent</td>

<td>supported,<br>
same as level 0</td>
<td>supported but deprecated,<br>
same as level 0</td><td>suppoerted,<br>same as level 0</td>
</tr>
<tr>
<td>2</td>
<td>&#8805; 1.4</td>
<td>recent,<br>
same as level 1</td>

<td>recent redesign</td>
<td>recent redesign</td><td>recent redesign</td>
</tr>
</tbody>
</table>
</p>
<ol>
<li><a name="note1"></a>PM123 version 1.32
does not check for the compatibility of plug-ins. When a wrong plug-in
is used, the application will most likely crash.</li>
</ol>
<p>For example a filter plug-in will be loaded depending on it's
interface level by a PM123 instance with interface level 2 (compile
time constant) in the following way:
<table border="1" cellpadding="3" cellspacing="0">
<tbody>
<tr>
<th>Interface level</th>
<th>Action taken</th>
</tr>
<tr>
<td>2</td>
<td>Loaded native</td>
</tr>
<tr>
<td>1</td>
<td>Loaded via a proxy in compatibility mode.</td>
</tr>
<tr>
<td>0</td>
<td>Loaded via a proxy in compatibility mode.<br>
Level 0 is identical to level 1 with respect to the filter plug-in
interface.</td>
</tr>
<tr>
<td>&gt;2</td>
<td>Error, because the interface is potentially
incompatible and not supported by this PM123 core.<br>
</td>
</tr>
</tbody>
</table>
</p>
</body></html>